<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>web服务端渲染服务架构化和接入</title>
      <link href="/2021/04/18/May_1st/"/>
      <url>/2021/04/18/May_1st/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSR是 Server-Side Rendering(服务器端渲染)的缩写，在普通的SPA中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作DOM（这里也是第一次访问SPA网站在同等带宽及网络延迟下比传统的在后端生成HTML发送到浏览器要更慢的主要原因。为了良好的用户体验和前后端分离，也可以将SPA应用打包到服务器上，在服务器上渲染出HTML发送到浏览器，能很大程度上解决首屏慢的问题，还能获得更好的SEO。</p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>该服务框架的目的是为了让业务页面更方便快捷的接入服务器端渲染，且多人协同开发时有良好的代码结构，清晰、便于维护。</p><h2 id="一、横向对比"><a href="#一、横向对比" class="headerlink" title="一、横向对比"></a>一、横向对比</h2><p>目前常用的SSR前端框架是基于react的<a href="https://nextjs.org/" target="_blank" rel="noopener">nextjs</a>和基于vue的<a href="https://nuxtjs.org/" target="_blank" rel="noopener">nuxtjs</a>，本文主要介绍基于nextjs的前端渲染模板来介绍，我们日常接触到的前端+nodejs服务端开发无非三种模式：</p><p>1、CSR（ Client-Side Rendering）即客户端渲染，倾向于静态页面开发，首屏数据的请求、获取和渲染是在客户端加载前端文件之后实现的，因此页面在用户看来会有闪屏和一段时间的空白，体验较差；</p><p>2、伪SSR模式即服务端返回的是未经渲染的html静态文件和首屏数据，也就是说页面（一般指首屏）还是在服务端加载，但无需额外发起请求获取渲染数据，这样确实解决了闪屏的问题，但还会存在较长时间的白屏，特别是在前端工程打包未做chunk优化时，体验一般（这也是我们目前采取的开发模式）；</p><p>3、SSR（Server-Side Rendering）即是本文要介绍的模式，服务端输出的是已经通过nextjs渲染引擎渲染好的前端页面和首屏数据，客户端不会出现白屏、闪屏和加载慢的问题，首屏展示的时间完全取决于服务接口返回耗时，大大缩短了首屏耗时，体验最好，并且能获得更好的SEO。</p><p><img src="/img/ssr1.png" alt=""></p><h2 id="二、框架搭建"><a href="#二、框架搭建" class="headerlink" title="二、框架搭建"></a>二、框架搭建</h2><p>搭建这个服务框架前，也做过一系列的思考和比较，如何即达到服务端渲染的功能目的，又能高效构建、自由扩展且规范开发；在基于目前的技术栈的前提下，提出了本文要介绍的nestjs+nextjs的解决方案，在保证组内成员接入上手简单的同时，也满足了上述要求。Nest 是一个用于构建高效，可扩展的 Node.js 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全持 TypeScript（但仍然允许开发人员使用纯 JavaScript 编写代码）并结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。</p><p>实现中，Nest的框架OOP模式也为实现服务端渲染带来了一定的麻烦，这也是搭建此框架最难的一点，下面会介绍如何解决。</p><h3 id="1、普通的express服务-nextjs的开发模式"><a href="#1、普通的express服务-nextjs的开发模式" class="headerlink" title="1、普通的express服务+nextjs的开发模式"></a>1、普通的express服务+nextjs的开发模式</h3><pre><code class="javascript">// express + next:const serve = express() // 实例化Serveconst app = next({dev: true}) //实例化next对象serve.get(‘’, (req. res)=&gt;{    return app.render(req, res, ’url’, data) // 服务直接返回next render出的页面})</code></pre><blockquote><p>这种开发方式弊端很多，例如文件散乱、耦合度高、路由混乱，服务端代码无工程化管理和输出，多成员开发维护困难等。</p></blockquote><h3 id="2、Nest-nextjs"><a href="#2、Nest-nextjs" class="headerlink" title="2、Nest + nextjs"></a>2、Nest + nextjs</h3><p>Nest的面向对象编程、代码工程化等虽然能解决上述弊端，但也会让各个module如何公用同一个next对象造成了很大麻烦，在每个controller文件里都const app = next()一次，这显然很不靠谱；在踩了很多坑后，解决方式：通过nest-next的node-module重写Nest的@Render()装饰器，在服务端的app.module文件里import实例化的next对象，具体实现逻辑可以查看源码，实现如下：</p><pre><code class="javascript">import { RenderModule } from &#39;nest-next&#39;;import Next from &#39;next&#39;;@Module({  imports: [    RenderModule.forRootAsync(      Next({        dev: process.env.NODE_ENV == &#39;development&#39;      })    ),    ContentModule  // 业务module  ],  controllers: [],  providers: [],})</code></pre><h3 id="3、代码打包和发布"><a href="#3、代码打包和发布" class="headerlink" title="3、代码打包和发布"></a>3、代码打包和发布</h3><p>这里又会牵扯到另一个问题，由于该服务是由nest和nextjs两种框架耦合而来，所以执行的build指令以及打包配置等都需要严格区分开，避免混乱；这里就不细展开了，主要是webpack相关的打包知识（有兴趣可以私下交流），也是踩了很多坑和不断的调试实现了服务的前端代码和服务代码本地开发调试、本地热更新、发布前的前端代码打包、服务端代码打包以及二者production模式下的配合。</p><h2 id="三、线上表现"><a href="#三、线上表现" class="headerlink" title="三、线上表现"></a>三、线上表现</h2><p>从目前已经接入服务的兴趣收集页面的Agies监控数据来看，在三秒开率（原来60%-90%，提升到现在100%左右）和首屏耗时（原来2000ms-3000ms，提升到现在100ms以内）两个首屏渲染的主要指标上，相对于之前的模式提升很显著。</p><blockquote><p>其中DOM_Ready的时长较长是由于业务页面加载了太多icon的cdn资源，需要业务方自己优化。</p></blockquote><h4 id="未接入SSR服务页面性能"><a href="#未接入SSR服务页面性能" class="headerlink" title="未接入SSR服务页面性能"></a>未接入SSR服务页面性能</h4><p><img src="/img/ssr2.png" alt=""></p><p><img src="/img/ssr3.png" alt=""></p><blockquote><p>CSR业务下发到页面曝光的漏斗：<br>pv：60%，uv：67.3%</p></blockquote><h4 id="资讯兴趣收集页面"><a href="#资讯兴趣收集页面" class="headerlink" title="资讯兴趣收集页面"></a>资讯兴趣收集页面</h4><p>1、主要指标：<br><img src="/img/ssr4.png" alt=""></p><p>2、各种网络环境下的表现：<br><img src="/img/ssr5.png" alt=""></p><h4 id="搜索兴趣收集页面"><a href="#搜索兴趣收集页面" class="headerlink" title="搜索兴趣收集页面"></a>搜索兴趣收集页面</h4><p>1、主要指标：<br><img src="/img/ssr6.png" alt=""></p><p>2、各种网络环境下的表现：<br><img src="/img/ssr7.png" alt=""></p><blockquote><p>兴趣收集业务下发到页面曝光的漏斗：<br>pv：80%，uv：92.6%</p></blockquote><h2 id="四、服务接入"><a href="#四、服务接入" class="headerlink" title="四、服务接入"></a>四、服务接入</h2><h3 id="1、工程的目录结构："><a href="#1、工程的目录结构：" class="headerlink" title="1、工程的目录结构："></a>1、工程的目录结构：</h3><p><img src="/img/ssr8.png" alt=""></p><h3 id="2、申明业务模块"><a href="#2、申明业务模块" class="headerlink" title="2、申明业务模块"></a>2、申明业务模块</h3><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>通过Nest提供的构建api自动构建module：nest g module moduleName</p><blockquote><p>根目录下执行，会在src目录生成对应module文件夹，以及自动引用到app.module，只需关注业务代码</p></blockquote><h4 id="controller-service"><a href="#controller-service" class="headerlink" title="controller/service"></a>controller/service</h4><p>自动构建service：nest g service moduleName<br>自动构建controller：nest g controller moduleName</p><blockquote><p>根目录下执行，会在src目录下对应module文件夹里生成对应文件、引用到module逻辑和jest测试用例模板，只需关注业务代码</p></blockquote><h3 id="3、业务服务端接入"><a href="#3、业务服务端接入" class="headerlink" title="3、业务服务端接入"></a>3、业务服务端接入</h3><p>代码如下：（对应上图的content.controller.ts）</p><pre><code class="javascript">import { Controller, Get, Render, Req, Res, Param, Query } from &#39;@nestjs/common&#39;;import { ContentService } from &#39;./content.service&#39;;@Controller(&#39;content&#39;)export class ContentController {    constructor(private readonly ContentService: ContentService) {}    // 未加Render修饰器的即为正常的ajax请求    @Get()    ajax() {        console.log(&#39;index&#39;, &#39;xxx&#39;)        return &#39;this is index&#39;    }    // 添加了Render修饰器的return的即为next渲染好的前端页面    @Render(&#39;content&#39;) // index文件不需要写路径，对应views/content/index.js页面    @Get(&#39;index&#39;)    index(@Param() param, @Query() query, @Req() req: Request, @Res() res: Response) {        const data = this.ContentService.getData() // 获取业务数据        return {}     }    @Render(&#39;content/main&#39;) // 非index文件需要写路径，对应views/content/main.js页面    @Get(&#39;main&#39;)    main(@Param() param, @Query() query, @Req() req: Request, @Res() res: Response) {        const data = this.ContentService.getData() // 获取业务数据        return {}    } } </code></pre><h3 id="4、前端页面数据获取"><a href="#4、前端页面数据获取" class="headerlink" title="4、前端页面数据获取"></a>4、前端页面数据获取</h3><p>服务端return的数据（例如{ data }），通过在前端代码中申明getServerSideProps方法的参数获取，该function为固定写法，return出的props会作用到该页面的props属性上，使用起来很方便。</p><pre><code class="javascript">// 获取nestjs返回的数据: ctx.queryexport async function getServerSideProps(ctx) {  console.log(&#39;ctx&#39;, ctx.query)  const query = ctx.query  return { props: query };}</code></pre><p>最后，对于该服务有不理解的地方、好的优化的点以及建议，欢迎联系交流。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算时代下的FaaS</title>
      <link href="/2021/01/08/Jan_8th/"/>
      <url>/2021/01/08/Jan_8th/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>云计算时代出现了大量XaaS形式的概念，从IaaS(Infrastructure as a Service)、PaaS(Platform as a Service)、SaaS(Software as a Service)到容器云引领的CaaS(Containers as a Service)，再到现在比较火热的微服务架构，其实他们做的都是尝试把各种软硬件资源抽象成一种服务提供给开发和运维，减少对基础设施、资源需求、中间件和中控调度等等的担心，更专注于业务的开发。FaaS即(Function as a Service)的简称，相较于微服务，它往往和无服务架构(Serverless Architecture)一同被提起。</p><h2 id="一、时光回溯"><a href="#一、时光回溯" class="headerlink" title="一、时光回溯"></a>一、时光回溯</h2><p>介绍无服务框架前，让我们回顾下部署的发展历史<br><img src="/img/container_evolution.svg" alt=""></p><h4 id="1、传统部署时代"><a href="#1、传统部署时代" class="headerlink" title="1、传统部署时代"></a>1、传统部署时代</h4><p>早期在物理服务器上运行应用程序，应用程序都在同一台物理机器上，无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且组织维护许多物理服务器的成本很高。</p><h4 id="2、虚拟化部署时代"><a href="#2、虚拟化部署时代" class="headerlink" title="2、虚拟化部署时代"></a>2、虚拟化部署时代</h4><p>作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的CPU上运行多个虚拟机（VM）。虚拟化允许应用程序在VM之间隔离，并提供一定程度的安全，因为一个应用程序的信息不能被另一应用程序随意访问。<br>虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。因此需要一层Hypervisor（虚拟机监视器）来统一监控、管理应用。</p><h4 id="3、容器部署时代"><a href="#3、容器部署时代" class="headerlink" title="3、容器部署时代"></a>3、容器部署时代</h4><p>容器类似于VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。<br>其中在容器部署中会有一层Container Runtime（容器运行时）的组件，运行时一般是用来支持程序运行的实现，例如JVM就是一种运行时。具体到容器运行时：就是运行容器所需要的一系列程序。docker在一开始是把这些所需都一起解决了，打包在每个容器里的镜像里，后来为了标准化，方便使用各种不同的实现，就分别进行了拆分，成立了Open Container Initiative (OCI)。推出了两个标准：<br>容器运行时标准：这个标准主要是指定容器的运行状态，和runtime需要提供的命令。<br>容器镜像标准：这个主要是说明容器的镜像的格式。这个一般是以OCI runtime filesytem bundle的形式存在。<br>简单来理解就是把容器运行所需的文件存放在文件夹里，用chroot控制访问，创建好cgroups和namespace实现容器隔离、运行docker和下载、管理、更新镜像以及提供RPC接口，用于远程提供服务。</p><h2 id="二、什么是FaaS"><a href="#二、什么是FaaS" class="headerlink" title="二、什么是FaaS"></a>二、什么是FaaS</h2><p>FaaS作为无服务架构Serverless的一种，Serverless的概念刚刚出现在HackerNews时并不为大众所接受。后来随着微服务和事件驱动架构的发展才慢慢引起关注。微服务架构近年来是一个非常火爆的话题，大大小小的公司都开始逐步分拆原来的单体应用，试着转换到由各个模块服务组合成大型的复杂应用。<br>Serverless可以看作是比微服务架构更细粒度的架构模式，即FaaS。它允许用户仅仅上传代码而无需提供和管理服务器，由它负责代码的执行、高可用扩展，支持从别的AWS服务或其他Web应用直接调用等；以电子商务应用为例，微服务中可以将浏览商品、添加购物车、下单、支付、查看物流等拆分为解耦的微服务。在FaaS里，它可以拆分到用户的所有CRUD操作代码，当发生“下单”事件时，只将触发相应的Functions。<br>现有以下的js代码</p><pre><code class="javascript">module.exports = (context, callback) =&gt; { callback(200, &quot;Hello, world!&quot;); }</code></pre><p>显然它是一个函数，通过FaaS的方式，我们可以通过访问一个URL的方式调用这个函数。</p><pre><code class="javascript">$ curl -XGET localhost:8080Hello, world!</code></pre><h2 id="三、FaaS特征"><a href="#三、FaaS特征" class="headerlink" title="三、FaaS特征"></a>三、FaaS特征</h2><p>1、FaaS里的应用逻辑单元都可以看作是一个函数，开发人员只关注如何实现这些逻辑，而不用提前考虑性能优化，让工作聚焦在这个函数里，而非应用整体。<br>2、FaaS是无状态的，天生满足云原生(Cloud Native App)应用该满足的12因子(12 Factors)中对状态的要求。无状态意味着本地内存、磁盘里的数据无法被后续的操作所使用。大部分的状态需要依赖于外部存储，比如数据库、网络存储等。<br>3、FaaS的函数应当可以快速启动执行，并拥有短暂的生命周期。函数在有限的时间里启动并处理任务，并在返回执行结果后终止。如果它执行时间超过了某个阈值，也应该被终止。<br>4、FaaS函数启动延时受很多因素的干扰。以AWS Lambda为例，如果采用了JS或Python实现了函数，它的启动时间一般不会超过10~100毫秒。但如果是实现在JVM上的函数，当遇到突发的大流量或者调用间隔过长的情况，启动时间会显著变长。<br>5、FaaS需要借助于API Gateway将请求的路由和对应的处理函数进行映射，并将响应结果代理返回给调用方。<br>对于一个简单的3层Web应用，在这里后端系统实现了大部分业务逻辑：认证、搜索、事务等，它的架构如下：<br><img src="/img/faas2.png" alt=""><br>采用Serverless架构，将认证、数据库等采用第三方的服务，从原来的单体后端里分拆出来(可能需要在原来的客户端里加入一些业务逻辑)。对于大部分的任务，通过函数的形式进行执行，而不再使用一直在线的服务器进行支持，如此一来它的架构看起来就清晰多了：<br><img src="/img/faas3.png" alt=""></p><h2 id="三、基于FaaS框架的Fission"><a href="#三、基于FaaS框架的Fission" class="headerlink" title="三、基于FaaS框架的Fission"></a>三、基于FaaS框架的Fission</h2><p>Fission是一款基于Kubernetes的FaaS框架。通过Fission可以轻而易举地将函数发布成HTTP服务。它通过读取用户的源代码，抽象出容器镜像并执行。同时它帮助减轻了Kubernetes的学习负担，开发者无需了解太多K8s也可以搭建出实用的服务。Fission可以与HTTP路由、Kubernetes Events和其他的事件触发器结合，所有这些函数都只有在运行的时候才会消耗CPU和内存。<br>Kubernetes提供了强大的弹性编排系统，并且拥有易于理解的后端API和不断发展壮大的社区。所以Fission将容器编排功能交给了K8s，让自己专注于FaaS的特性。<br><img src="/img/faas4.png" alt=""></p><p>对于FaaS来说，它最重要的两个特性是将函数转换为服务和管理服务的生命周期。<br>FaaS优化了函数运行时的资源使用，它的目标是在运行的时候才消费资源。但在冷启动的时候可能会有些资源使用过载，比如对于用户登录的过程，无论多等几秒都是不可接受的。为了改变这个问题，Fission维持了一个面向任何环境容器池。当有函数进来时，Fission无需启动新容器，直接从池里取一个，将函数拷贝到容器里，执行动态加载，并将请求路由到对应的实例。<br><img src="/img/faas5.png" alt=""></p><p>除了安装在本地的Fission主程序外，Fission-bundle设计为一组微服务构成:</p><blockquote><p>Controller: 记录了函数、HTTP路由、事件触发器和环境镜像<br>Pool Manager: 管理环境容器，加载函数到容器，函数实例空闲时杀掉<br>Router: 接受HTTP请求，并路由到对应的函数实例，必要的话从Pool Manager中请求容器实例</p></blockquote><p>当Router收到外部请求，它先去缓存Cache里查看是否在请求一个已经存在的服务。如果没有，要访问请求映射的服务函数，需要向Pool Manager申请一个容器实例执行函数。Pool Manager拥有一个空闲Pod池，它选择一个Pod，并把函数加载到里面（通过向容器里的Sidecar发送请求实现），并且把Pod的地址返回给Router。Router将外部请求代理转发到该Pod，并将响应结果返回。Pod会被缓存起来以应对后续的请求。如果空闲了几分钟，它就会被杀死。</p><h2 id="四、执行流程"><a href="#四、执行流程" class="headerlink" title="四、执行流程"></a>四、执行流程</h2><p>如果是第一次运行，需要先准备NodeJS的运行环境：</p><pre><code class="bash">fission env create --name nodejs --image fission/node-env</code></pre><p><img src="/img/faas6.png" alt=""><br>同样，由fission主程序执行命令function和子命令create，通过–name参数指定函数名为hello，–env参数确定环境，–code参数确定要执行的函数代码。通过POST向/v1/functions发出请求，携带函数信息的JSON。controller拿到JSON后进行函数资源的存储。首先将拿到UUID，然后写到文件名为该UUID的文件里。接着向ETCD的API发送HTTP请求，在file/name路径下有序存放UUID。最后类似上面env命令，将UUID和序列化后的JSON数据写到ETCD里。</p><pre><code class="bash">fission function create --name hello --env nodejs --code hello.js</code></pre><p><img src="/img/faas7.png" alt=""><br>fission通过参数–method指定请求所需方法为GET，–url指定API路由为hello，–function指定对应执行的函数为hello。通过POST向/v1/triggers/http发出请求，将路由和函数的映射关系信息发送到controller。controller会在已有的trigger列表里进行重名检查，如果不重复，才会获取UUID并将序列化后的JSON数据写到etcd里。</p><pre><code class="bash">fission route create --method GET --url /hello --function hello</code></pre><p><img src="/img/faas8.png" alt=""><br>当执行该curl时，请求发送至router容器。收到请求后会转发到两个对应的handler。一个是用户定义的面向外部的，一个是内部的。实际上它们执行的是同一个handler。任何handler都会先根据funtion名去Cache里查找对应的service名。如果没有命中，将通过poolmgr为函数创建新的Service，并把记录添加到Cache。然后生成一个反向代理，接收外部请求，然后转发至Kubernetes Service。</p><pre><code class="bash">curl http://$FISSION_ROUTER/hello</code></pre><p><img src="/img/faas9.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深圳打工一年了，加油！打工人！🤙</title>
      <link href="/2020/10/15/22_02_21/"/>
      <url>/2020/10/15/22_02_21/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深圳打工一年了，加油！打工人！🤙</title>
      <link href="/2020/10/15/Sep_27th/"/>
      <url>/2020/10/15/Sep_27th/</url>
      
        <content type="html"><![CDATA[<p>来了来了，该来的还是来了，一年一度的感动深圳又开始了，这次的主题是深圳打工一周年。害！从19年9月开始到现在都已经1年零2个月了，在tx一年感觉还行嗷，皮厚一点，每行代码都排期，工作一下子也不是那么忙嘛；终于有时间来整理我这一身肥肉，刚来的时候还是140出头的精神小伙，过完年就成160了，气抖冷。不过好在连续4个月锻炼重回颜值巅峰…..的一半，好在能看了，148的人，多那8斤的肌肉也不是不可以，这大胸肌这大宽背，啧！<br><img src="/img/change.png" alt=""></p><p>在深圳打工一年最大的理想就是用自己的钱买个房，要求不高，芜湖靠江就行；害！感觉自己有心理障碍了，什么东西都不想被别人给，一毛钱我都有心理负担，有点理解iron man不喜欢别人递东西给他了，虽然什么东西都要自己赚累点，好在还是够了，偶尔得个季度奖、发个mate xs什么的，咱就是说也挺开心！</p><p>国庆回家参加了好多婚礼，还当了个伴郎（穿衬衫还是有点帅的嗷），本来都觉得是最后结婚的人最早结婚了；难噢难噢，万花丛中过，片叶不粘身？</p><img src="/img/pig.gif" width="50%" style='border-radius: 5px;'><p>这次的感动深圳晚会到此结束了，我们来年再见吧，如果爸比还在深圳的话🐧🐒</p><p>⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️⛔️</p><div align="center" width="100%">    <video src="/img/zjl.mp4" controls="controls" style='width: 100%;border-radius: 5px; margin-bottom: 10px'></div><div align="center" width="100%">    <img src="/img/body.jpg" width="49%" style='margin-right:1%;'>    <img src="/img/cat.jpg" width="49%"></div>]]></content>
      
      
      <categories>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平时遇到的一些css写法</title>
      <link href="/2020/04/21/css/"/>
      <url>/2020/04/21/css/</url>
      
        <content type="html"><![CDATA[<h2 id="1-scale后的居中操作"><a href="#1-scale后的居中操作" class="headerlink" title="1.scale后的居中操作"></a>1.scale后的居中操作</h2><p>dom被scale后，由于缩小的中心点默认选在了中间，会造成一定的偏移</p><pre><code class="css">{    transform: &#39;scale(0.9) translate(-50%)&#39;;    position: &#39;absolute&#39;;    left: 50%;    transform-origin: &#39;0 0 0&#39; // 缩小点选在左上方}</code></pre><h2 id="2-右边文字随着左边图片变小而适配"><a href="#2-右边文字随着左边图片变小而适配" class="headerlink" title="2.右边文字随着左边图片变小而适配"></a>2.右边文字随着左边图片变小而适配</h2><pre><code class="css">.image {    width: auto;    height: 162px;    .image-pic {      width: 216px;      max-width: 216px; // 限制图片最大宽度      height: 100%;      border-radius: 4px;    }}.container {    width: 100%; // 右边容器宽度设置100%    height: 162px;    // padding: 0 10px;  }  .text {    width: auto;    height: 162px;    min-width: 510px;    .bottom-wrap {      width: 100%; // 下方按钮设置100%宽      height: 48px;    }  }</code></pre><hr><hr><hr><p>by 2020/4/21 19:10:20<br>今天就想到这两个，先就写这么多: )</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容易忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs的缓存组件和缓存穿透问题</title>
      <link href="/2020/03/30/node_cache/"/>
      <url>/2020/03/30/node_cache/</url>
      
        <content type="html"><![CDATA[<h2 id="1-需求背景"><a href="#1-需求背景" class="headerlink" title="1.需求背景"></a>1.需求背景</h2><p>在推荐页请求热点数据的请求中，热点数据刷新间隔是半小时一次，因为返回热点数据的服务可承受的请求量较小，并且数据在刷新间隔内是不会变化的，没必要所有的用户请求都透传到后续服务（推荐场景一天将近1.2亿次的pv），这会对后台服务要求太高也没必要，所以需要在node服务层做缓存数据，每次用户的请求从缓存中返回并且每30min node服务更新一次数据。</p><h2 id="2-缓存数据分类"><a href="#2-缓存数据分类" class="headerlink" title="2.缓存数据分类"></a>2.缓存数据分类</h2><p>目前接触到的数据主要分为两大类吧：</p><ol><li>有边界数据：这种数据是指请求的数据可以一次性全部返回，后续的请求都可以沿用上次请求的数据，类似的有热点数据等；</li><li>无边界数据：这种是指数据带有特征性质，上个用户的请求不能给下个用户请求用，类似的有用户画像等数据<br>先附上老大给写的c++伪码吧，我后面也自己封装了个node版的</li></ol><pre><code class="c++">/* * LocalCache.h * *  Created on: 2020.3.16 *      Author: bostinshi */#ifndef LocalCache_H_#define LocalCache_H_typedef promise::Future&lt;int&gt; CommonRetFuture;template&lt;typename T&gt;typedef CommonRetFuture FuncSyncData(const T &amp;); // Func是函数类型；template&lt;typename T, typename TKey,  typename TVal&gt;class LocalCache {public:    LocalCache(size_t iCacheSize, size_t iBaseKey,            size_t iShmSize, size_t iDataMaxSize, size_t iDataMinSize,            int iEffectTime, int iReqIntvalTime, bool bSyncGetData,            FuncSyncData&lt;T&gt; fSyncData            ) {        m_iEffectTime = iEffectTime;        m_iReqIntvalTime = iReqIntvalTime;        m_bSyncGetData = bSyncGetData;        m_cache.initDataBlockSize(iDataMinSize, iDataMaxSize, 1.0);        m_cache.initStore(iBaseKey, iShmSize);        m_cache.initLock(iBaseKey);        m_cache.setAutoErase(true);        m_cache.setEraseMode(TC_HashMap::ERASEBYGET);    }    void doInterval()    {        fSyncData();    }    CommonRetFuture get(const TKey&amp; stKey, TVal&amp; stVal)    {        promise::Promise&lt;ECommonRetCode&gt; promise;        //REPORT_COUNT(&quot;ProfileCache.get.request&quot;, 1);        int shmRet = m_cache.get(stKey, stVal);        //MT_RLOG&lt;&lt;&quot;get  : &quot;&lt;&lt;stKey.sMkey&lt;&lt;&quot;|shmRet :&quot;&lt;&lt; shmRet &lt;&lt; &quot;|iRefreshTime:&quot; &lt;&lt; iRefreshTime &lt;&lt;endl;        if (shmRet != TC_HashMap::RT_OK)        {            //LOGDEBUG&lt;&lt; &quot;get fail : &quot; &lt;&lt; stKey.sMkey &lt;&lt; &quot;|shmRet :&quot; &lt;&lt; shmRet &lt;&lt;endl;            //REPORT_COUNT(&quot;ProfileCache.get.retfailed_&quot;+taf::TC_Common::tostr(shmRet), 1);            promise.setValue(shmRet);            return promise.getFuture();        }        long lNowMs = TC_TimeProvider::getInstance()-&gt;getNowMs();        int iTimeInterval = lNowMs - stVal.iTimeStamp;        if (iTimeInterval &gt; m_iEffectTime) // refresh time        {            if(m_bSyncGetData)            {                return fSyncData(stKey);            }            else            {                if(!stVal.bHasReq || (lNowMs - stVal.iTimeStamp) &gt; m_iReqIntvalTime)                {                    stVal.bHasReq = true;                    stVal.iReqTimeStamp = lNowMs;                    set(stKey, stVal);                    fSyncData(stKey);                }                promise.setValue(shmRet);// time out data                return promise.getFuture();            }        }        return shmRet;    }    int set(const TKey&amp; stKey, TVal&amp; stVal)    {        int shmRet = m_cache.set(stKey, stVal);        if (shmRet != TC_HashMap::RT_OK)        {            //MT_RELOG&lt;&lt;&quot;set fail : &quot;&lt;&lt;stKey.sMkey&lt;&lt;&quot;|shmRet :&quot;&lt;&lt; shmRet &lt;&lt;endl;            //REPORT_COUNT(&quot;ProfileCache.set.retfailed_&quot;+taf::TC_Common::tostr(shmRet), 1);        }        //MT_RLOG&lt;&lt;&quot;set  : &quot;&lt;&lt;stKey.sMkey&lt;&lt;&quot;|shmRet :&quot;&lt;&lt; shmRet &lt;&lt;endl;        return shmRet;    }private:    int m_iEffectTime;    int m_iReqIntvalTime;    bool m_bSyncGetData;    FuncSyncData&lt;T&gt; fSyncData;    T m_cache;};#endif /* LocalCache_H_ */</code></pre><h2 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3.实现代码"></a>3.实现代码</h2><p>组件主要实现了3个基本方法，get、set和getCacheKeys，主要的逻辑就是始终保持catch里面有数据，就会保证数据每次都是从node缓存里取回，不会对后续服务造成缓存穿透和太大响应压力；无论是打底的数据还是上次取回来的缓存，或者是上上次取回来的过期的缓存，在get函数返回的数据中，都会用code这个字段区分当前数据的性质：100-&gt;打底数据 200-&gt;正常缓存数据 300-&gt;过期缓存数据。</p><pre><code class="javascript">export const Cache : any = {};Cache.global = {}Cache.cacheObj = {}/** * 获取对应key值的缓存 * @param key 缓存对应的key值 */Cache.get = (key) =&gt; {    if (Object.keys(Cache.cacheObj).indexOf(key) &gt; -1) {        return Cache.cacheObj[key]    } else {        throw `暂无当前key值为：${key}的缓存`    }}/** * 将取回来的数据存进缓存 * 传回去的数据结构{code: xxx, data: 取回的数据} * 状态码：100-&gt;打底数据 200-&gt;正常缓存数据 300-&gt;过期缓存数据 * @param asyfun 异步请求数据的func，需要返回data或者error * @param normal_interval 正常情况下向后台取数据的间隔 * @param error_interval 缓存穿透后调整的取数据间隔 * @param key 缓存对应的key值 * @param backData 打底的数据 {code: 100, data: 打底数据} */Cache.set = async function (asyfun, normal_interval, error_interval, key, backData)  {    for (let cacheKey in Cache.cacheObj) {        if (cacheKey === key) {            Monitor.report(&#39;cache key duplicate&#39;, `key值重复，重复的key值：${key}`);            throw `key值重复，当前已有key值：${Object.keys(Cache.cacheObj)}`         }    }    Cache.global[key + &#39;timer&#39;] = null    async function intervalFunc() {         try {            let res = await asyfun()            Cache.cacheObj[key] = {code: 200, data: res}        } catch (e) {            console.log(&#39;cache error&#39;, e)            if (Cache.cacheObj[key].data &amp;&amp; Cache.cacheObj[key].code &amp;&amp; Cache.cacheObj[key].code === 200) { // 缓存里是上次的缓存，修改状态码是300                Cache.cacheObj[key].code = 300            } else if (Cache.cacheObj[key].data &amp;&amp; Cache.cacheObj[key].code &amp;&amp; Cache.cacheObj[key].code === 300) { // 缓存里是很久的缓存，修改状态码是300                Cache.cacheObj[key].code = 300            } else {                Cache.cacheObj[key] = {code: 100, data: backData}            }        }    }    try {        let res = await asyfun()        Cache.cacheObj[key] = {code: 200, data: res}        if (Cache.global[key + &#39;timer&#39;]) {            clearInterval(Cache.global[key + &#39;timer&#39;])        }        Cache.global[key + &#39;timer&#39;] = setInterval(intervalFunc, normal_interval)    } catch (e) { // 取数据操作异常        Monitor.report(&#39;cache get error&#39;, e);        if (Cache.cacheObj[key] &amp;&amp; Cache.cacheObj[key].data &amp;&amp; Cache.cacheObj[key].code &amp;&amp; Cache.cacheObj[key].code === 200) { // 缓存里是上次的缓存，修改状态码是300            Cache.cacheObj[key].code = 300        } else if (Cache.cacheObj[key] &amp;&amp; Cache.cacheObj[key].data &amp;&amp; Cache.cacheObj[key].code &amp;&amp; Cache.cacheObj[key].code === 300) { // 缓存里是很久的缓存，修改状态码是300            Cache.cacheObj[key].code = 300        } else {            Cache.cacheObj[key] = {code: 100, data: backData}        }        if (Cache.global[key + &#39;timer&#39;]) {            clearInterval(Cache.global[key + &#39;timer&#39;])        }        Cache.global[key + &#39;timer&#39;] = setInterval(intervalFunc, error_interval)    }}/** * 获取当前已有缓存的key值 */Cache.getCacheKeys = () =&gt; {    return Object.keys(Cache.cacheObj)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来深圳4个月了...</title>
      <link href="/2019/12/23/%20Dec_23rd/"/>
      <url>/2019/12/23/%20Dec_23rd/</url>
      
        <content type="html"><![CDATA[<p>从7月中旬收到鹅厂offer，到9月1号入职，再到现在12月底，一下就过了4个月了；回头看下，刚上班的时候，不适应这边2周一个迭代的需求进度，需求排期也没怎么参与，都是被动接受需求，产品同学说几天交付就定几天；啧啧啧，忙到吐了，加班到12点持续了一个月，不夸张的讲每天早上睡得模模糊糊的时候脑子都会自动想没交付的需求，md 一度想回家种田。<br><img src="/img/%E6%97%A0fuck%E5%8F%AF%E8%AF%B4.jpeg" alt=""><br>还好后面受到同事“指导”，要利用好产品同学的期待，哈哈哈🤣2天能做好的需求定4天，哇，突然就闲了下来，那感受一点都不夸张，就和夏天穿着究极不透气的解放鞋跑完马拉松后脱下袜子之后的那种清爽，脑子也不嗡嗡了，脖子也不痛痛了。</p><p>想起来了，刚来深圳的时候感觉贼惨，像是什么都丢了来了这边，加上某人说的什么“你的不快乐就是我最大的快乐”这种骚话，哇，心态爆炸；不过好在某人意识到自身重大错误比较快，平时下班也和我说说话到很晚，后面表现还是挺好的👌，除了回应晚一点之外，还行吧。。。</p><p>还有，最近总是会回想，很奇怪，可能是这几天小区对面那个工地打桩机吵得我精神衰弱了吧= =昨晚睡前翻了一遍手机里的照片，从2016年到现在的，竟然还看到了张13年的大学信管三个班+电子商务的同学合影，我记得好像是玩了个什么比赛，奖品是罐装雪碧可乐，人人都有，就我没有…啧啧啧，发现自己6年前还不是很土，很欣慰🙃继续说回想的事情，坐在那一想就是个把小时，各种想我那时候要是那样会怎么怎么样，那么做多好什么的，越想越入戏，有点恐怖…<br><img src="/img/think.JPG" alt=""><br>就差不多和上面那种感觉一样，外表平静，脑子里稀奇古怪的乱想😂想完之后人就清爽了，还是当下是对的，要是以前真的那么做了现在真的就啥都没了，想想还是很怕人的…</p><p>十三年前还是十四年前第一来深圳，记不太清了，万万没想到以后会来深圳上班，哎，前两天去了当年去的世界之窗看了看，还是那么假233333😂，毕竟勉强算是童年吧，太蠢了…</p><p>不写了不写了，就写这么多了，太矫情了，我还是不适合写这种恶心人的东西，放几张我最近拍的还阔以的照片，感觉有点内味儿了，细品…</p><div align="center" width="100%">    <img src="/img/4.jpg" width="48%" style='margin-right: 5px;'>    <img src="/img/3.jpg" width="48%"></div><div align="center" width="100%">    <img src="/img/2.jpg" width="48%" style='margin-right: 5px;'>    <img src="/img/1.jpg" width="48%"></div>]]></content>
      
      
      <categories>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/05/20/seccloud_fourth/"/>
      <url>/2018/05/20/seccloud_fourth/</url>
      
        <content type="html"><![CDATA[<h2 id="10-ES6使用小结"><a href="#10-ES6使用小结" class="headerlink" title="10.ES6使用小结"></a>10.ES6使用小结</h2><p>这部分呢打算对项目中用到的ES6语法做个小总结吧: )仅是对项目使用的部分做记录，有兴趣的可以去看看阮一峰的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></p><h3 id="1-promise"><a href="#1-promise" class="headerlink" title="1.promise"></a>1.promise</h3><p>Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。<br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="javascript">// 创建promise实例const promise = new Promise(function(resolve, reject) {  // ... some code  if (/* 异步操作成功 */){    resolve(value);  } else {    reject(error);  }});// Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。promise.then(function(value) {  // success}, function(error) {  // failure});</code></pre><h4 id="举两个栗子吧"><a href="#举两个栗子吧" class="headerlink" title="举两个栗子吧"></a>举两个栗子吧</h4><pre><code class="javascript">// 简单操作function timeout(ms) {  return new Promise((resolve, reject) =&gt; {    setTimeout(resolve, ms, &#39;done&#39;); // 第三个参数会作为resolve函数的参数使用  });}timeout(100).then((value) =&gt; {  console.log(value); // 打印done});    // 稍复杂操作const getJSON = function(url) {  const promise = new Promise(function(resolve, reject){    const handler = function() {      if (this.readyState !== 4) {        return;      }      if (this.status === 200) {        resolve(this.response);       } else {        reject(new Error(this.statusText)); // 分类进不同的回调      }    };    const client = new XMLHttpRequest();    client.open(&quot;GET&quot;, url);    client.onreadystatechange = handler;    client.responseType = &quot;json&quot;;    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);    client.send();  });  return promise; // 返回promise对象是继续回调的关键};getJSON(&quot;/posts.json&quot;).then(function(json) {  console.log(&#39;Contents: &#39; + json);}, function(error) {  console.error(&#39;出错了&#39;, error);});</code></pre><blockquote><p>promise新建后会执行some code的代码块，再执行后面的代码，最后执行resolve和reject的部分</p></blockquote><h4 id="链式回调，避免回调地狱"><a href="#链式回调，避免回调地狱" class="headerlink" title="链式回调，避免回调地狱"></a>链式回调，避免回调地狱</h4><p>多层的回调看起来十分不美观而且不易数据维护，在js中引入链式操作会变得优雅很多。</p><pre><code class="javascript">yPromise(value){    return new Promise(function(resolve, reject){        setTimeout(function(){            if(value == 1002){                resolve(value+1)            }            else {                reject(&#39;yuhui&#39;)            }        },value)    })}this.yPromise(1000)  .catch(function(err){ // 调用resolve或reject并不会终结 Promise 的参数函数的执行。    console.log(err)    // return Promise.resolve(1000)    return Promise.reject(2000) // 要想继续回调必须返回一个promise对象}).catch(function(err){    console.log(err)    return Promise.resolve(1000)}).then(function(res){    console.log(res)    // var res2 = res + 1000    // return new Promise(function(resolve, reject){    //     resolve(res2)    // })    return Promise.resolve(res+1000) //等价于上面的写法}).then(function(res){    console.log(res)    return Promise.resolve(res+1000)})</code></pre><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/promise_1.PNG" alt=""></p><h3 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2.箭头函数"></a>2.箭头函数</h3><p>待续。。。: p</p><h3 id="3-Set数据结构"><a href="#3-Set数据结构" class="headerlink" title="3.Set数据结构"></a>3.Set数据结构</h3><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。  </p><pre><code class="javaacript">// 记住简单的用法就行let set = new Set([1,2,2,3,3,4])[...set]  // [1,2,3,4]set.size // 4</code></pre><h4 id="实例化Set"><a href="#实例化Set" class="headerlink" title="实例化Set"></a>实例化Set</h4><p>ES6 提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。  </p><pre><code class="javascript">const set = new Set([1,2,3,3,4,5])console.log([...set])// orconst set = new Set()[1,2,3,3,4,5].forEach ((val, index) =&gt; {set.add(val)})console.log([...set])// 1,2,3,4,5  size:5// 有个比较有意思的现象// 直接add一个数组，而不是把数组元素一个个addconst set = new Set()set.add([1,2,3,4,5,5])console.log([...set])// [1,2,3,4,5,5] size:1  会多一个一样的add的数组且可以含有重复元素</code></pre><blockquote><p>1.既可以在实例化Set的时候把数组当参数传进Set()构造函数，也可以用Set对象的add方法添加成员。<br>2.Set函数可以接受一个数组（<strong>或者具有 iterable 接口的其他数据结构</strong>）作为参数，用来初始化</p></blockquote><h4 id="特性和用法"><a href="#特性和用法" class="headerlink" title="特性和用法"></a>特性和用法</h4><p>1.针对Set数据结构元素不重复的特性，可以很简单的对数组去重</p><pre><code class="javascript">[...new Set(array)] // 去重array</code></pre><p>也可以用于字符串去重</p><pre><code class="javascript">[...new Set(&#39;aabbccd&#39;)].join(&#39;&#39;) // 去重array</code></pre><blockquote><p>join() 方法用于把数组中的所有元素放入一个字符串，默认以逗号分割；可接受字符串参数x，即以x分割数组  </p></blockquote><p>2.向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法类似于<strong>精确相等运算符</strong>（===），主要的区别是在Set内部NaN等于自身，而精确相等运算符认为NaN不等于自身。</p><pre><code class="javascript">let set = new Set()let a = NaNlet b = NaNset.add(a)set.add(b)set // Set {NaN} 去重后NaN === NaN // false</code></pre><p>另外，两个对象总是不相等的。</p><pre><code class="javascript">let set = new Set();set.add({})set.size // 1set.add({})set.size // 2{} === {} // false</code></pre><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><ol><li><p>Set 结构的实例有以下属性。</p><ul><li>Set.prototype.constructor：构造函数，默认就是Set函数。</li><li>Set.prototype.size：返回Set实例的成员总数。  </li></ul></li><li><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li>add(value)：添加某个值，返回 Set 结构本身。</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>clear()：清除所有成员，没有返回值。<pre><code class="javascript">s.add(1).add(2).add(2);// 注意2被加入了两次</code></pre></li></ul></li></ol><p>s.size // 2</p><p>s.has(1) // true<br>s.has(2) // true<br>s.has(3) // false</p><p>s.delete(2);<br>s.has(2) // false</p><pre><code>另外，除了之前的[...set]这种方式把set类型转换成数组外，Array的from()方法也可以。```javascriptlet set = new Set([1,2,2,3,3,4])let arr = Array.from(set) // [1,2,3,4]</code></pre><h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p>Set结构的实例有四个遍历方法，可以用于遍历成员。  </p><ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ul><blockquote><p>需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p></blockquote><h5 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h5><p>keys方法、values方法、entries方法返回的都是遍历器对象（也就是Iterator对象）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p><pre><code class="javascript">let set = new Set([&#39;yu&#39;, &#39;zheng&#39;, &#39;hui&#39;]);for (let item of set.keys()) {  console.log(item);}// yu// zheng// huifor (let item of set.values()) {  console.log(item);}// yu// zheng// huifor (let item of set.entries()) {  console.log(item);}// [&quot;yu&quot;, &quot;yu&quot;]// [&quot;zheng&quot;, &quot;zheng&quot;]// [&quot;hui&quot;, &quot;hui&quot;]</code></pre><blockquote><p>entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p></blockquote><p>另外，Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。</p><pre><code class="javacript">Set.prototype[Symbol.iterator] === Set.prototype.values// true// 可以省略values方法，直接用for...of循环遍历 Setfor (let item of set) { // 等同于for (let item of set.values())  console.log(item)}// yu// zheng// hui</code></pre><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h5><p>Set结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><pre><code class="javascript">let set = new Set([1, 4, 9]);set.forEach((val, key) =&gt; console.log(key + &#39; : &#39; + val))// 1 : 1// 4 : 4// 9 : 9</code></pre><blockquote><p>Set的forEach方法的参数就是一个处理函数，该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，<strong>Set结构的键名就是键值（两者是同一个值），</strong>因此第一个参数与第二个参数的值永远都是一样的。</p></blockquote><h4 id="Array和Set组合应用"><a href="#Array和Set组合应用" class="headerlink" title="Array和Set组合应用"></a>Array和Set组合应用</h4><ol><li>数组的map和filter方法也可以间接用于Set了<pre><code class="javascript">let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：{2, 4, 6}</code></pre></li></ol><p>let set = new Set([1, 2, 3, 4, 5]);<br>set = new Set([…set].filter(x =&gt; (x % 2) == 0));<br>// 返回Set结构：{2, 4}</p><pre><code>2. 使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）```javascriptlet a = new Set([1, 2, 3])let b = new Set([4, 3, 2])// 并集let union = new Set([...a, ...b])// Set {1, 2, 3, 4}// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)))// set {2, 3}// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)))// Set {1}</code></pre><h3 id="4-Map数据结构"><a href="#4-Map数据结构" class="headerlink" title="4.Map数据结构"></a>4.Map数据结构</h3><p>基本用法</p><pre><code class="javascript">const map = new Map([    [true, 1],[{}, 1],[&#39;y&#39;, &#39;h&#39;]])map // {true =&gt; 1, {…} =&gt; 1, &quot;y&quot; =&gt; &quot;h&quot;}</code></pre><p>Map数据结构它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。</p><pre><code class="javascript">const m = new Map()const o = {p: &#39;Hello World&#39;} // 这里的对象一定要用声明的变量作为key，保证set和get是指向同一块内存m.set(o, &#39;content&#39;)m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false</code></pre><blockquote><p>上面代码使用Map结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol><li>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。<pre><code class="javascript">const map = new Map([[&#39;name&#39;, &#39;yyy&#39;],[&#39;title&#39;, &#39;hhh&#39;]])</code></pre></li></ol><p>map.size // 2<br>map.has(‘name’) // true<br>map.get(‘name’) // “yyy”<br>map.has(‘title’) // true<br>map.get(‘title’) // “hhh”</p><pre><code>&gt; Map构造函数接受数组作为参数，本质上还是执行了arr.forEach([key,val], index) =&gt; map.set(key, val)2. 不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素的数组的数据结构，都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。```javascriptconst set = new Set([[&#39;yyy&#39;,1],[&#39;zzz&#39;,2],[&#39;hhh&#39;,3]])const map = new Map([[&#39;yyy&#39;,4],[&#39;zzz&#39;,5],[&#39;hhh&#39;,6]])const origin_map1 = new Map(set)const origin_map2 = new Map(map)origin_map1.get(&#39;yyy&#39;) // 1origin_map2.get(&#39;yyy&#39;) // 4</code></pre><blockquote><p>分别使用Set对象和Map对象当作Map构造函数的参数，结果都生成了新的Map对象。</p></blockquote><ol start="3"><li>如果对同一个键多次赋值，后面的值将覆盖前面的值；不存在的键对应的值都是undefined。<pre><code class="javascript">const map = new Map()</code></pre></li></ol><p>map<br>.set(1, ‘aaa’)<br>.set(1, ‘bbb’)</p><p>map.get(1) // “bbb”</p><p>map.get(‘asfddfsasadf’) // undefined</p><pre><code>4. 只有对**同一个对象**的引用，Map 结构才将其视为同一个键。```javascriptconst map = new Map()map.set([&#39;a&#39;], 555)map.get([&#39;a&#39;]) // undefinedlet key = [&#39;a&#39;] // 赋值给变量后get和set引用的都是同一块内存了map.set(key, 555)map.get(key) // 555</code></pre><blockquote><p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，两个对象的内存地址是不一样的，因此get方法无法读取该键，返回undefined。</p></blockquote><ol start="5"><li>同样的值的两个实例，在Map结构中被视为两个键<pre><code class="javascript">const map = new Map()</code></pre></li></ol><p>const k1 = [‘a’]<br>const k2 = [‘a’]</p><p>map<br>.set(k1, 111)<br>.set(k2, 222)</p><p>map.get(k1) // 111<br>map.get(k2) // 222</p><pre><code>&gt; 变量k1和k2的值是一样的，但是它们指向的是两块不同的内存，因此在Map结构中被视为两个键综上所述，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。  如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等（===），Map将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。  **虽然NaN不严格相等于自身，但Map将其视为同一个键。**```javascriptlet map = new Map()map.set(-0, 123)map.get(+0) // 123map.set(true, 1)map.set(&#39;true&#39;, 2)map.get(true) // 1map.set(undefined, 3)map.set(null, 4)map.get(undefined) // 3map.set(NaN, 123)map.get(NaN) // 123</code></pre><h4 id="属性和操作方法"><a href="#属性和操作方法" class="headerlink" title="属性和操作方法"></a>属性和操作方法</h4><p>Map 结构的实例有以下属性和操作方法：</p><ol><li>属性<ul><li>size 返回Map结构的成员总数</li></ul></li><li>方法<ul><li>set(key, value) 设置键名key对应的键值为value，然后返回整个Map结构</li><li>get(key) 读取key对应的键值</li><li>has(key) 返回一个布尔值，表示某个键是否在当前 Map 对象之中</li><li>delete(key) 删除某个键，返回true。如果删除失败，返回false</li><li>clear() 清除所有成员，没有返回值</li></ul></li></ol><pre><code class="javascript">const map = new Map()map.set(&#39;foo&#39;, true)map.set(&#39;bar&#39;, false)map.size // 2map.set(&#39;yyy&#39;, 1).set(&#39;zzz&#39;, 2) // set方法返回的是map对象，因此可以有链式写法map.get(&#39;yyy&#39;) // 1map.get(&#39;hhh&#39;) // undefinedmap.set(undefined, &#39;hah&#39;)map.get(undefined) // hahmap.has(undefined) // truemap.delete(&#39;yyy&#39;) // 成功后返回truemap.has(&#39;yyy&#39;) // faslemap.clear()map.has(undefined) // false</code></pre><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><p>和Set一样，Map也提供三个遍历器生成函数和一个遍历方法。  </p><ul><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回所有成员的遍历器。</li><li>forEach()：遍历 Map 的所有成员。</li></ul><h5 id="keys-values-entries"><a href="#keys-values-entries" class="headerlink" title="keys() values() entries()"></a>keys() values() entries()</h5><blockquote><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p></blockquote><pre><code class="javascrpt">const map = new Map([  [&#39;F&#39;, &#39;no&#39;],  [&#39;T&#39;,  &#39;yes&#39;],]);for (let key of map.keys()) {  // 遍历key  console.log(key);}// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) { // 遍历value  console.log(value);}// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) { // 遍历Map成员  console.log(item[0], item[1]);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) {  console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) { // Map默认的遍历方法（Symbol.iterator属性）就是entries  console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;</code></pre><h5 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h5><p>Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。</p><pre><code class="javascript">map.forEach(function(value, key, map) {  console.log(&quot;Key: %s, Value: %s&quot;, key, value)})const reporter = {  report: function(key, value) {    console.log(&quot;Key: %s, Value: %s&quot;, key, value)  }}map.forEach(function(value, key, map) {  this.report(key, value)}, reporter)</code></pre><blockquote><p>forEach()可以接受第二个参数，可以改变this的指向</p></blockquote><h4 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h4><h5 id="1-Map转成数组"><a href="#1-Map转成数组" class="headerlink" title="1.Map转成数组"></a>1.Map转成数组</h5><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。</p><pre><code class="javascript">const map = new Map([  [1, &#39;one&#39;],  [2, &#39;two&#39;],  [3, &#39;three&#39;]])[...map.keys()]// [1, 2, 3][...map.values()]// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;][...map.entries()]// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]][...map]// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]</code></pre><p>从而可以结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p><pre><code class="javascript">const map0 = new Map()  .set(1, &#39;a&#39;)  .set(2, &#39;b&#39;)  .set(3, &#39;c&#39;)const map1 = new Map(  [...map0].filter(([k, v]) =&gt; k &lt; 3) // [k, v]结构赋值)// 产生 Map 结构 {1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;}const map2 = new Map(  [...map0].map(([k, v]) =&gt; [k * 2, &#39;_&#39; + v]))// 产生 Map 结构 {2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;}</code></pre><h5 id="2-Map转为对象"><a href="#2-Map转为对象" class="headerlink" title="2.Map转为对象"></a>2.Map转为对象</h5><pre><code class="javascript">let obj = Object.create(null)const map = new Map([    [&#39;y&#39;,1],[&#39;z&#39;,2],[&#39;h&#39;,3]])map.forEach(function(v,k) {    obj[k] = v})// orfor (let [k,v] of map) {    obj[k] = v}</code></pre><blockquote><p>这样无损转换的前提是key都是字符串，如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p></blockquote><h5 id="3-对象转为Map"><a href="#3-对象转为Map" class="headerlink" title="3.对象转为Map"></a>3.对象转为Map</h5><pre><code class="javascript">let obj = {&#39;y&#39;: 1, &#39;z&#39;: 2, &#39;h&#39;: 3}const map = new Map()for (let k in obj) {    map.set(i, obj[i])}// orfor (let k of Object.keys(obj)) { //Object.keys(obj) =&gt; [&#39;y&#39;,&#39;z&#39;,&#39;h&#39;]    map.set(i, obj[i])}</code></pre><h5 id="3-Map转为JSON"><a href="#3-Map转为JSON" class="headerlink" title="3.Map转为JSON"></a>3.Map转为JSON</h5><pre><code class="javascript">let obj = Object.create(null)const map = new Map([    [&#39;y&#39;,1],[&#39;z&#39;,2],[&#39;h&#39;,3]])map.forEach(function(v,k) {    obj[k] = v})// orfor (let [k,v] of map) {    obj[k] = v}JSON.stringify(obj) // 在Map转换成对象的基础上JSON.stringify()</code></pre><p>另一种情况是当Map的键是非字符串时，这时候可以选择转成JSON数组</p><pre><code class="javascript">const map = new Map([    [true,1],[{&#39;y&#39;: h},2],[&#39;h&#39;,3]])const arr = [...map] // [[true,1],[{&#39;y&#39;: h},2],[&#39;h&#39;,3]]JSON.stringify(arr)</code></pre><h3 id="5-解构"><a href="#5-解构" class="headerlink" title="5.解构"></a>5.解构</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><pre><code class="javascript">// 以前赋值let a = 1let b = 2let c = 3// 用解构赋值let [a,b,c] = [1,2,3]</code></pre><blockquote><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p></blockquote><p><strong>完全解构：</strong></p><pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]]foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]third // &quot;baz&quot;let [x, , y] = [1, 2, 3]x // 1y // 3let [head, ...tail] = [1, 2, 3, 4]head // 1tail // [2, 3, 4]</code></pre><p><strong>解构不成功：</strong></p><pre><code class="javascript">let [foo] = []let [bar, foo] = [1]foo // undefinedlet [x, y, ...z] = [&#39;a&#39;]x // &quot;a&quot;y // undefinedz // []</code></pre><p><strong>不完全解构：</strong><br>等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><pre><code class="javascript">let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4</code></pre><p><strong>解构报错：</strong><br>如果等号的右边不是数组或者严格地说，不是可遍历的结构，那么将会报错。</p><pre><code class="javascript">// 报错let [foo] = 1let [foo] = falselet [foo] = NaNlet [foo] = undefinedlet [foo] = nulllet [foo] = {}</code></pre><blockquote><p>上面的语句都会报错，因为等号右边的值，要么<strong>转为对象</strong>以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p></blockquote><p><strong>有Iterator接口数据格式的结构</strong><br>例如Set数据结构和Generator函数：</p><pre><code class="javascript">let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])x // &quot;a&quot;// Generator函数function* fibs() {  let a = 0;  let b = 1;  while (true) {    yield a;    [a, b] = [b, a + b];  }}let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5</code></pre><blockquote><p>fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/05/20/seccloud_fifth/"/>
      <url>/2018/05/20/seccloud_fifth/</url>
      
        <content type="html"><![CDATA[<h2 id="11-基于token的登录认证"><a href="#11-基于token的登录认证" class="headerlink" title="11.基于token的登录认证"></a>11.基于token的登录认证</h2><p>主要从sessions、cookies和token来说<br>待续。。。: p<br>——————920更——————</p><h3 id="1-基于token的会话验证："><a href="#1-基于token的会话验证：" class="headerlink" title="1.基于token的会话验证："></a>1.基于token的会话验证：</h3><p>用户登录系统后与服务器建立起会话，为了保持会话避免重复登录，因此浏览器登录第一次后需要一个可以证明自己身份的东西，让服务器知道这是一个曾经登录过的用户并且知道是谁，从而响应对应用户的请求；由于HTTP请求是无状态的，因此区分每一个用户是一个不小的困难。<br>在介绍基于token的身份验证之前，可以想到要解决这个问题，用户第一次登录后，服务器回应用户一个会话ID就，用户请求时带上这个ID，服务器检索到这个ID对应的是谁，就可以回应正确的请求了；这对于少量用户群体来说还行，但对于用户量过多的系统，服务器存储的压力就太大了，而且基于负载均衡的服务器集群不能保证一个用户的每次请求都在第一台保存用户ID的服务器上。<br>所以这个ID不应该让服务器存，但如果不存的话服务器又不知道请求的是不是合法的用户。<br>基于token的身份验证：用户第一次登陆后，服务器生成一个由user_id和签名（用服务器秘钥加密后的user_id），二者组合成一个token（令牌）发给浏览器。</p><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/token1.png" alt=""></p><p>之后的每次请求浏览器把token带着，每次服务器解密token里的签名对比明文的user_id，一致的话就可以知道用户是谁了，避免了服务器存储session_id的压力。</p><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/token2.png" alt=""></p><h3 id="2-cookie"><a href="#2-cookie" class="headerlink" title="2.cookie"></a>2.cookie</h3><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv的形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 </p><h3 id="3-session"><a href="#3-session" class="headerlink" title="3.session"></a>3.session</h3><p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p><p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p><p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p><h2 id="12-VUE源码笔记"><a href="#12-VUE源码笔记" class="headerlink" title="12.VUE源码笔记"></a>12.VUE源码笔记</h2><p><a href="https://github.com/Alexandermclean/vue/blob/dev/src/core/instance" target="_blank" rel="noopener">源码链接</a></p><blockquote><p>在看源码前需要先了解一下强类型模板类的js语言，类似typescript或是flow，vue2.0就是用flow写的（原因<a href="https://www.zhihu.com/question/46397274" target="_blank" rel="noopener">链接</a>）个人看完之后觉得flow好用一点，轻量不干预源码。</p></blockquote><h2 id="13-vue-nodejs-webpack环境搭建"><a href="#13-vue-nodejs-webpack环境搭建" class="headerlink" title="13.vue+nodejs+webpack环境搭建"></a>13.vue+nodejs+webpack环境搭建</h2><p>又要写另一个项目了 = =记录一下基于webpack搭建Vue开发环境的操作和配置</p><h3 id="1-vue-cli搭建框架"><a href="#1-vue-cli搭建框架" class="headerlink" title="1.vue-cli搭建框架"></a>1.vue-cli搭建框架</h3><p>vue init webpack xxx–cd xxx–npm install</p><h3 id="2-nodejs启动dev"><a href="#2-nodejs启动dev" class="headerlink" title="2.nodejs启动dev"></a>2.nodejs启动dev</h3><p>新建一个webpack_server.js的配置文件，从webpack.base.conf.js和webpack.dev.conf.js中选择相应的配置代码<br>主要是：entry、output、module和plugins这四个对象，其中entry是输入，webpack会将输入的文件及在其中导入的文件一起打包；output是输出，指定输出文件的目录，文件名等；module是预处理方式，webpack只能处理js文件，还有很多其他类型的文件，如css，图片，typescript，sass等文件，为了使webpack能顺利打包，那就需要预处理一下；plugins顾名思义就是提供一些额外的功能，相当于插件例如inject：插入output资源特定的位置，可以为head，body等，minify：压缩html文件。</p><p>主要涉及的文件：build下的webpack.base.conf.js和webpack.dev.conf.js、config/index.js、package.json和main.js，列一下关于配置中比较重要的几个点：<br>1.npm express后，在根目录下创建一个server文件夹，在里面新建一个node的启动文件app.js</p><p>2.app.js中主要用’webpack-dev-middleware’模块打包运行dev，用webpack-hot-middleware实现修改文件后的热加载（除express文件外），对于express文件修改的热加载可以用nodemon实现，个人感觉nodemon和webpack-hot-middleware配合可以让项目调试起来很方便。</p><pre><code class="javascript">const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;);const webpackHotMiddleware = require(&#39;webpack-hot-middleware&#39;);const webpackConfig = require(&#39;../build/webpack-server.js&#39;);const webpack = require(&#39;webpack&#39;);const compiler = webpack(webpackConfig);if (setting.webpack.isWebpackDev){    app.use(webpackDevMiddleware(compiler,{        publicPath: webpackConfig.output.publicPath,        noInfo: true    }));    app.use(webpackHotMiddleware(compiler));}</code></pre><p>3.当express侦听某个接口时，输入的路径是“/”或“/index.html”这种默认路径时，需要用中间件拦截指向启动后的dev的html入口文件，即打包后根目录下的dist/index.html</p><pre><code class="javascript">var DIST_DIR = path.join(__dirname, &#39;../&#39;, &#39;dist&#39;)app.get([&quot;/&quot;, &quot;/index.html&quot;], (req, res, next) =&gt;{  const filename = path.join(DIST_DIR, &#39;index.html&#39;);  compiler.outputFileSystem.readFile(filename, (err, result) =&gt;{    if(err){        return(next(err))    }    res.set(&#39;content-type&#39;, &#39;text/html&#39;)    res.send(result)    res.end()  })})</code></pre><p>4.webpack打包的配置文件设置，webpack(webpackConfig)这一步就是用配置文件创建一个用来传给webpack-middle-ware的对象，主要修改了entry和plugins，entry添加webpack-hot-middleware/client入口和plugins添加热加载的插件new webpack.optimize.OccurrenceOrderPlugin()和new webpack.HotModuleReplacementPlugin()。</p><p>正常启动命令，也可以在package.json的scripts里面自定义一个启动命令：<br><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/nodemon.PNG" alt=""></p><h3 id="3-集成插件和工具"><a href="#3-集成插件和工具" class="headerlink" title="3.集成插件和工具"></a>3.集成插件和工具</h3><p>1.router<br>路由的具体设置可以看<a href="https://github.com/Alexandermclean/Security-Cloud-Project#1%E8%B7%AF%E7%94%B1router" target="_blank" rel="noopener">上文</a>，有专门针对路由设置的详细介绍；或者目录下的<a href="https://github.com/Alexandermclean/Security-Cloud-Project/blob/master/buildvue/src/router/index.js" target="_blank" rel="noopener">项目代码</a>。</p><pre><code class="javascript">// main.jsimport router from &#39;./router&#39;// router文件夹下index.jsimport Vue from &#39;vue&#39;import Router from &#39;vue-router&#39;Vue.use(Router)</code></pre><p>2.vuex </p><pre><code class="javascript">// main.js文件import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import vuexStore from &#39;./store/index&#39;Vue.use(Vuex)new Vue({  store: vuexStore})// store 结构 index.js和modules文件夹// index.jsimport Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import common from &#39;./modules/common&#39;Vue.use(Vuex)const store = new Vuex.Store({    modules: {        common: common    }})export default store// modules/common.jsconst state = {    name: &#39;WAF&#39;}const getters = {    getName: state =&gt; state.name}const mutations = {}const actions = {}export default {    // namespaced: true,  // 命名空间问题TODO    state,    getters,    mutations,    actions}</code></pre><p>3.axios </p><pre><code class="javascript">import axios from &#39;./api/axios&#39;Vue.prototype.$axios = axios// api/axiosimport axios from &#39;axios&#39;axios.defaults.timeout = 5000// 防止IE浏览器的GET操作请求同一接口时从缓存拿数据axios.defaults.headers = Object.assign(axios.defaults.headers, {&#39;Cache-Control&#39;: &#39;no-cache&#39;})export default axios</code></pre><p>4.iview </p><pre><code class="javascript">import iView from &#39;iview&#39;import &#39;iview/dist/styles/iview.css&#39;Vue.use(iView)// 需要在webpack配置文件中的module.rules添加css、postcss、less等规则{    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })}</code></pre><p>5.jquery</p><pre><code class="javascript">// main.jsimport $ from &#39;jquery&#39;new Vue({  el: &#39;#app&#39;,  router,  components: { App },  template: &#39;&lt;App/&gt;&#39;,  $: $,  store: vuexStore})// node打包配置文件webpack-server.js// 在plugins中添加new webpack.ProvidePlugin({  $: &#39;jquery&#39;,  jQuery: &#39;jquery&#39;})</code></pre><p>6.公共样式</p><pre><code class="javascript">// vue-loader.js文件，添加入口css文件路径和输出文件名称entry: {    common: &#39;../static/css/common.css&#39;},output: {    filename: &#39;./css/[name].css&#39;}// webpack-server文件，entry中添加import公共css文件的js文件style: [&quot;./static/js/style.js&quot;]// static/js/style.js文件import &#39;../css/common.css&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/05/20/seccloud_seventh/"/>
      <url>/2018/05/20/seccloud_seventh/</url>
      
        <content type="html"><![CDATA[<h2 id="17-关于上传和下载"><a href="#17-关于上传和下载" class="headerlink" title="17.关于上传和下载"></a>17.关于上传和下载</h2><p>最近的需求呢关于上传下载的特别多=  =先说下载吧，之前我也就构造一个form的dom结构，再通过submit()方法提交，只要后台提供的是正常的文件流的话，浏览器会自动生成文件，但有一点需要注意的是返回头必须是application/octet-stream，这点你可以自己在node层加工一下返回头。但自从我发现了一个叫Blob的类之后就觉得这种方法更方便了，可以像正常的ajax请求一样请求文件流到前端自己处理，就避免了当传参复杂的时候form表单的局限性，具体实现下面再细说；再说说上传吧，上传主要是结合了前端<a href="http://fex.baidu.com/webuploader/" target="_blank" rel="noopener">WebUploader</a>以及nodejs的formidable模块实现的，具体怎么实现也是下面细说。  </p><h3 id="1-上传"><a href="#1-上传" class="headerlink" title="1.上传"></a>1.上传</h3><p>主要过程就是前端通过引入webUploader类来构造uploader对象，通过参数配置实现对接node层的处理上传的中间件。</p><pre><code class="javascript">// vue文件import webuploader from &#39;~js/webuploader/webuploader.min.js&#39;this.uploader = webuploader.create({    // 列出几个我觉得比较重要的参数    // 具体的奇遇参数可参考官方文档    auto: true, // 选择完文件后是否自动上传    server: api/xxx/xx // 文件接收端地址，对应的是nodejs中间件的url    accept: { // 上传的文件类型        title: &#39;ak&#39;,        exteensions: &#39;ak&#39;,        mimeTypes: &#39;.ak&#39;    },    chunked: true, // 是否分片上传，针对较大文件})// 这里会列出来webuploader的一些钩子函数，方便在上传的不同步骤中做相应的事情// 利用on函数绑定不同事件触发的不同函数，例如：this.uploader.on(&#39;fileQueued&#39;, (file) = &gt; {    do something // 文件被添加到队列中hook，做对文件类型的判断})// 官方文档也给出了一种较简单的写法this.uploader.onFileQueued = function (file) {    do something // 文件被添加到队列中hook}this.uploader.on(&#39;uploadStart&#39;, (file) = &gt; {    do something // 文件开始上传的hook})this.uploader.on(&#39;uploadProgress&#39;, (file) = &gt; {    do something // 文件上传中的hook，可做进度条之类的需求})this.uploader.on(&#39;uploadSuccess&#39;, (file) = &gt; {    do something // 文件上传成功的hook})</code></pre><blockquote><p>前端对于上传文件的操作主要集中在几个hook函数中，用于告知用户上传文件的进程和结果</p></blockquote><pre><code class="javascript">// nodejsrouter.use(&#39;api/xxx/xx&#39;, function (req, res, next) {    utils.uploadFile(core.url, req)})// utils.jsvar formidable = require(&#39;formidable&#39;)var formData = require(&#39;form-data&#39;)var utils = {    uploadFile: function (url, req) {        // 这部分url的参数根据项目要求来        let tag = req.qurey.tag // 用来标识这是个上传动作        let module = req.qurey.module // 存储到数据库的哪个模块        return new Promise(function(resolve, reject) {            var formfile = new formidable.IncomingForm()            var formSubmit = new formData()            formfile.parse(req, function(err, fields, files) {                req.body = fields                req.files = files                // and so on 根据不同需求决定            })        })    }}</code></pre><blockquote><p>node这边用到的主要是几个模块，例如formidable、path、form-data、fs、os等，这里的上传不涉及到前端人员存入数据库的过程，增加node层主要是为了简化前端代码，避免客户端卡顿；同时在node层封装文件流、请求和返回对象。</p></blockquote><h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2.下载"></a>2.下载</h3><p>至于下载呢，我一直是不太喜欢用前端构造form表单的形式，这样会显得笨重而且麻烦。前端时间写的关于下载安装包文件的需求，根据后台返回的二进制文件流利用Blob对象生成可点击下载的a标签，在dom上节省了很大一部分，而且是基于ajax请求的，因此在传参上很方便。</p><pre><code class="javascript">// 还是先简单的写下构造form表单的下载吧template部分&lt;form action=&#39;api/xxx/xxx&#39; method=&#39;post&#39; id=&#39;download&#39; name=&#39;downloadForm&#39;&gt;    &lt;input id=&#39;type&#39; type=&#39;hidden&#39; name=&#39;type&#39; value=&#39;&#39;&gt;&lt;/form&gt;script部分let type-data = JSON.stringify(object-data) // 如果需要传的参数是对象或者数组之类的，可以先stringify一下$(&#39;#type&#39;).attr(&#39;value&#39;, type-data)$(&#39;#download&#39;).submit() // 触发提交表单</code></pre><blockquote><p>这种方式的好处是浏览器会根据返回的二进制文件流自动生成对应的文件，不需要对返回的流做处理</p></blockquote><pre><code class="javascript">// ajax请求+Blob对象的方式this.$axios({    method: &#39;POST&#39;,    url: &#39;api/xxx/xxx&#39;,    responseType: &#39;arraybuffer&#39;, // 这里比较重要，要规定后台返回的类型是二进制流，才不会造成文件打不开的情况    data: {        type: {xx: xxx}    }}).then(r =&gt; {    const blob = new Blob([r.data], {type: &#39;application/zip&#39;})    const url = window.URL || window.webkitURL || window.moxURL    const href = url.createObject(blob)    let link = document.createElement(&#39;a&#39;)    link.href = href    link.display = none    document.body.appendChild(link)    link.click    document.body.removeChild(link)})</code></pre><blockquote><p>这样的方式好处就是传参便捷、不用构造form表单和自定义强度高，可以对返回的文件流做自定义加工，例如文件名、文件格式之类，只要在link.click()之前都可以；只是对于node层来说，可能需要对返回的数据做加工，返回的可能就不只是单单一个文件流了，可以以对象的方式返回包含文件名、文件类型、文件大小等参数，便于前台展示。</p></blockquote><p>后面有时间找到了更便捷的下载上传方式再来更新吧，目前就这么多了 : )</p>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/05/20/seccloud_sixth/"/>
      <url>/2018/05/20/seccloud_sixth/</url>
      
        <content type="html"><![CDATA[<h2 id="14-HTTPS协议加密机制"><a href="#14-HTTPS协议加密机制" class="headerlink" title="14.HTTPS协议加密机制"></a>14.HTTPS协议加密机制</h2><h3 id="1-为什么要加密"><a href="#1-为什么要加密" class="headerlink" title="1.为什么要加密"></a>1.为什么要加密</h3><p>因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，他还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最简单容易理解的就是对称加密。</p><h3 id="2-加密的种类"><a href="#2-加密的种类" class="headerlink" title="2.加密的种类"></a>2.加密的种类</h3><h4 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1.对称加密"></a>1.对称加密</h4><p>通信双方各持一个相同的秘钥，对通信的内容加密解密，这种加密方式优点就是加密解密速度快，效率高。<br>但是怎么能保证通信的双方都拿到相同的秘钥而不被其他人拿到呢，这就很难了= =</p><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2.非对称加密"></a>2.非对称加密</h4><p>就是有两把秘钥，一把私钥，一把公钥；用公钥加密的内容只能私钥解密，同样私钥加密的内容只能公钥解密。鉴于非对称加密的机制，我们会有这种思路：服务器先把公钥直接明文传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开这条数据。</p><p>然而由服务器到浏览器的这条路怎么保障安全？如果服务器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。所以目前似乎只能保证由浏览器向服务器传输数据时的安全性。  </p><h4 id="3-改良版的非对称加密"><a href="#3-改良版的非对称加密" class="headerlink" title="3.改良版的非对称加密"></a>3.改良版的非对称加密</h4><p>既然一对私钥秘钥能保证一方面的通信安全，那用两队公钥私钥就能保证互相通信安全了 : )<br>1.某网站拥有用于非对称加密的公钥A、私钥A’；浏览器拥有用于非对称加密的公钥B、私钥B’。<br>2.浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。<br>3.浏览器把公钥B明文传输给服务器。<br>4.之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有这个私钥A’可以解密，所以能保证这条数据的安全。<br>5.服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。</p><p>的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心，而对称加密快很多。</p><h4 id="4-非对称加密-对称加密"><a href="#4-非对称加密-对称加密" class="headerlink" title="4.非对称加密+对称加密"></a>4.非对称加密+对称加密</h4><p>既然非对称加密耗时，非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，而且非对称加密、解密各只需用一次即可。<br>1.某网站拥有用于非对称加密的公钥A、私钥A’。<br>2.浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。<br>3.浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。<br>4.服务器拿到后用私钥A’解密得到密钥X。<br>5.这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。  </p><p>但是！这样会有另一个问题，中间人劫持替换了服务器给浏览器的公钥A，换成了自己伪造的公钥B，浏览器生成的对称秘钥X用公钥B加密后被劫持，劫持者用自己的私钥B’解密得到秘钥X，用之前劫持的公钥A加密后给服务器，服务器也会得到一样的秘钥X，但这时秘钥X已经泄露了= =<br>因此需要一个证明，证明浏览器收到的公钥确实是需要通信的服务器给的，类似于现实中张三向李四证明自己是张三一样，张三可以出具自己的身份证给李四，证明自己是张三；但是又有个问题，我不是张三但我伪造了一个张三的身份证，我好像就变成了张三了；这个时候身份证的真伪就必须有个权威机构来证明比如公安局，在公安局证明了手上的张三的身份证是真的的时候，你就是张三了。兜了一大圈，终于证明了我就是我了。</p><h4 id="5-数字证书（CA证书）"><a href="#5-数字证书（CA证书）" class="headerlink" title="5.数字证书（CA证书）"></a>5.数字证书（CA证书）</h4><p>互联网中，CA机构就像是公安局，数字证书就是服务器的身份证，证书里包括了证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，证书就如身份证一样，可以证明“该公钥对应该网站”，浏览器从证书里取公钥就行了。<br>但证书是明文传递的，就像之前的公钥一样，因此需要一个不能伪造的标记证明CA证书的真实性；这里的解决办法和上面的token的做法差不多，CA证书除了有网站的信息的明文外，还会附带有一个由CA机构私钥加密明文内容的签名，这两者共同组成了数字证书。<br>数字签名的制作过程：<br>1.CA拥有非对称加密的私钥和公钥。<br>2.CA对证书明文信息进行hash。<br>3.对hash后的值用私钥加密，得到数字签名。  </p><p><img src="./assets/ca.jpg" alt=""></p><p>浏览器验证过程：<br>1.拿到证书，得到明文T，数字签名S。<br>2.用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。<br>3.用证书里说明的hash算法对明文T进行hash得到T’。<br>4.比较S’是否等于T’，等于则表明证书可信。</p><blockquote><p>有一点，CA机构的公钥是否可信的问题，操作系统或浏览器一般会预装一些他们信任的CA机构的数字证书，也就是我们常看到的<strong>根证书</strong>，根证书则包含了该CA机构的公钥，用于浏览器和该CA机构信任的web服务器通信，类似于一个信任链，浏览器信任根证书里的公钥，发布该公钥的CA机构信任它认证的web服务器。</p></blockquote><p>另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，也就是没有该机构的根证书，你就得手动下载安装（风险自己承担 : p）。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p><h4 id="6-HTTPS协议的会话保持"><a href="#6-HTTPS协议的会话保持" class="headerlink" title="6.HTTPS协议的会话保持"></a>6.HTTPS协议的会话保持</h4><p>看完上述基于HTTPS协议加密的通信，会觉得过程很繁琐，如果每次请求在SSL/TLS层进行握手阶段，都要经历一次密钥传输过程会非常耗时，那怎么达到只传输一次呢？用session就行。<br>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。</p><p><img src="./assets/ca2.jpg" alt=""></p><blockquote><p>不由得感叹一句，网络安全真的很难得啊 = =</p></blockquote><h2 id="15-关于IE9浏览器CSS文件大小限制问题"><a href="#15-关于IE9浏览器CSS文件大小限制问题" class="headerlink" title="15.关于IE9浏览器CSS文件大小限制问题"></a>15.关于IE9浏览器CSS文件大小限制问题</h2><p>前两天搭完新项目的环境跑在chrome浏览器是正常的，但在IE9里面样式失效了，具体表现就是写在vue文件中style标签里的样式不起作用，但在行内或是外联的CSS样式是可以的= =<br>找了资料和研究了一哈，根本原因是在IE9里面单个CSS文件大小不能超过234kb，超过的部分会被浏览器忽略，由于项目框架引入了iview组件，iview的css文件较大，因此写在style标签里的样式被忽略了。<br>所以可以把引用iview组件的css的操作从main.js转移到static里的style.js来引用，类似于引用common.css的做法。  </p><pre><code class="javascript">webpack-server.js // 打包配置文件entry: {    app: [&quot;webpack-hot-middleware/client&quot;, &quot;babel-polyfill&quot;, &quot;./src/main.js&quot;],    style: [&quot;./static/js/style.js&quot;, &quot;webpack-hot-middleware/client&quot;]  } // 入口文件加入了style.jsstatic/js/style.js // 引入样式的js文件import &#39;../css/common.css&#39;</code></pre><p>这样做确实可以解决IE9里面css文件过大导致样式失效的问题，但是和我一开始想用切割打包后的css文件的做法不一样= = emmmmmm猜想应该是放在static文件夹里的文件打包的时候webpack都会自动压缩，所以文件大小要小很多。</p><h2 id="16-计算机网络小结"><a href="#16-计算机网络小结" class="headerlink" title="16.计算机网络小结"></a>16.计算机网络小结</h2><p>经过一系列神奇的事情，我又来更新一下最近的感触 : ) 作为前端还是需要知道关于计算机网络的一些协议的，痛心疾首啊T T</p><h3 id="1-计算机网络协议架构"><a href="#1-计算机网络协议架构" class="headerlink" title="1.计算机网络协议架构"></a>1.计算机网络协议架构</h3><p>OSI（Open System Interconnect）开放式系统互联，一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。<br>最早的时候网络刚刚出现的时候，很多大型的公司都拥有了网络技术，公司内部计算机可以相互连接。可以却不能与其它公司连接。因为没有一个统一的规范。计算机之间相互传输的信息对方不能理解。所以不能互联。<br>ISO为了更好的使网络应用更为普及，就推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。  </p><p>不同协议在最初OSI模型中的位置：  </p><table><thead><tr><th align="center">7</th><th align="left">应用层</th><th align="left">例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP</th></tr></thead><tbody><tr><td align="center">6</td><td align="left">表示层</td><td align="left">例如XDR、ASN.1、SMB、AFP、NCP</td></tr><tr><td align="center">5</td><td align="left">会话层</td><td align="left">例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td align="center">4</td><td align="left">传输层</td><td align="left">例如TCP、UDP、RTP、SCTP、SPX、ATP、IL</td></tr><tr><td align="center">3</td><td align="left">网络层</td><td align="left">例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25</td></tr><tr><td align="center">2</td><td align="left">链路层</td><td align="left">例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP</td></tr><tr><td align="center">1</td><td align="left">物理层</td><td align="left">例如线路、无线电、光纤、信鸽</td></tr></tbody></table><p>第7层应用层—直接对应用程序提供服务，应用程序可以变化，但要包括电子消息传输；<br>第6层表示层—格式化数据，以便为应用程序提供通用接口。这可以包括加密服务；<br>第5层会话层—在两个节点之间建立端连接。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层4中处理双工方式；<br>第4层传输层—常规数据递送－面向连接或无连接。包括全双工或半双工、流控制和错误恢复服务；<br>第3层网络层—本层通过寻址来建立两个节点之间的连接，它包括通过互连网络来路由和中继数据；<br>第2层数据链路层—在此层将数据分帧，并处理流控制。本层指定拓扑结构并提供硬件寻址；<br>第1层物理层—原始比特流的传输，电子信号传输和硬件接口数据发送时，从第七层传到第一层，接受方则相反。  </p><blockquote><p>上三层总称应用层，用来控制软件方面；下四层总称数据流层，用来管理硬件，数据在发至数据流层的时候将被拆分。根据PDU （协议数据单元）：在传输层的数据叫段（segment），网络层叫包（packet），数据链路层叫帧（frame），物理层叫比特流（bit），其他更高层次的数据则是报文（message）</p></blockquote><p>OSI中每一层都有每一层的作用。比如网络层就要管理本机的IP的目的地的IP。数据链路层就要管理MAC地址（介质访问控制）等等，所以在每层拆分数据后要进行封装，以完成接受方与本机相互联系通信的作用。  </p><h3 id="2-下层协议"><a href="#2-下层协议" class="headerlink" title="2.下层协议"></a>2.下层协议</h3><p>互联网是由一整套协议构成的，规定了在不同通信层的要求。</p><h4 id="1-Ethernet（以太网）"><a href="#1-Ethernet（以太网）" class="headerlink" title="1.Ethernet（以太网）"></a>1.Ethernet（以太网）</h4><p>互联网中最底层的是以太网协议，它规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p><h4 id="2-IP协议"><a href="#2-IP协议" class="headerlink" title="2.IP协议"></a>2.IP协议</h4><p>上面的以太网协议可以解决一个局域网内的点对点通信，但是不能解决不同局域网之间的通信，IP协议就是为了解决这种情况。  </p><p><img src="./assets/ip_protocol.jpg" alt="">  </p><blockquote><p>如上图所示，IP协议可以连接多个局域网  </p></blockquote><p>IP协议定义了一套自己的地址规则，称为IP地址。它实现了路由功能，允许某个局域网的A主机向另一个局域网的B主机发送消息。<br>我们买的路由器就是基于IP协议，局域网之间需要靠路由器连接；路由器背部有很多网口，其内部有一张路由表，规定了A段IP地址的出口a，B段IP地址的出口b……通过这套“指路牌”实现了数据包的转发。  </p><p><img src="./assets/ip_table.jpg" alt="">  </p><blockquote><p>这张路由表注明了不同IP段目的地的数据包，要发送到哪个端口（interface）  </p></blockquote><p>IP协议只是一个地址协议，并不保证数据包的完整，如果路由器丢包（路由器内存满了，新进来的数据包就会丢失），就需要发现哪一个数据包丢失，以及重新补发这个数据包。这就需要依靠TCP协议了。<br><strong>简单来说，TCP协议的作用就是保证数据通信的完整性和可靠性，防止丢包。</strong></p><h4 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3.TCP协议"></a>3.TCP协议</h4><h5 id="1-数据包大小"><a href="#1-数据包大小" class="headerlink" title="1.数据包大小"></a>1.数据包大小</h5><p>以太网数据包（packet）大小是固定的，最初是1518个字节，后来增加到1522个字节。其中1500个字节是负载（payload），22个字节是头信息（head）。<br>IP数据包在以太网数据包的负载里，也有自己的头信息，最少需要20字节，所以IP数据包的负载最多是1480个字节。  </p><p><img src="./assets/packetsize.png" alt="">  </p><blockquote><p>IP数据包在以太网数据包负载里，TCP数据包在IP数据包负载里  </p></blockquote><p>TCP数据包在IP数据包的负载里，它的头信息最少也需要20个字节，因此TCP数据包的最大负荷是1460个字节。由于IP协议和TCP协议往往有额外的头信息，所以实际的TCP数据包大概是1400个字节。  </p><p><img src="./assets/packet_simple.png" alt=""></p><h5 id="2-TCP数据包编号（SEQ）"><a href="#2-TCP数据包编号（SEQ）" class="headerlink" title="2.TCP数据包编号（SEQ）"></a>2.TCP数据包编号（SEQ）</h5><p>一个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个10MB的文件，需要发送7100多个包。<br>发送的时候，TCP协议为每个包编号（sequence number，简称SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。<br>例如第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。  </p><p><img src="./assets/tcp_length.png" alt="">  </p><blockquote><p>当前包的编号是45943，下一个数据包的编号是46183，由此可知，这个包的负载是240字节。</p></blockquote><h5 id="3-TCP数据包的组装"><a href="#3-TCP数据包的组装" class="headerlink" title="3.TCP数据包的组装"></a>3.TCP数据包的组装</h5><p>收到TCP数据包以后，组装还原是操作系统完成的。应用程序不会直接处理TCP数据包。对于应用程序来说，不用关心数据通信的细节。除非线路异常，除此之外收到的总是完整的数据。应用程序需要的数据放在TCP数据包里面，但<strong>要把TCP数据变成应用层可识别的数据</strong>，就要有自己的格式（比如HTTP协议）。  </p><p>TCP并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP协议就有一个头信息Content-Length，表示信息体的大小。对于操作系统来说，就是持续地接收TCP数据包，将它们按照顺序组装好，一个包都不少。操作系统不会去处理TCP数据包里面的数据。一旦组装好TCP数据包，就把它们转交给应用程序。TCP数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。应用程序收到组装好的原始数据，以浏览器为例，就会根据HTTP协议的Content-Length字段正确读出一段段的数据。这也意味着，一次TCP通信可以包括多个HTTP通信。</p><h5 id="4-发送窗口"><a href="#4-发送窗口" class="headerlink" title="4.发送窗口"></a>4.发送窗口</h5><p>接收方每收到两个TCP数据包，就要发送一个确认消息。“确认”的英语是 acknowledgement，所以这个确认消息就简称ACK。</p><blockquote><p>ACK 携带两个信息：</p><blockquote><p>1.期待要收到下一个数据包的编号<br>2.接收方的接收窗口的剩余容量  </p></blockquote></blockquote><p>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为“发送窗口”，这个窗口的大小是可变的。  </p><p><img src="./assets/seq_ack.png" alt="">  </p><p>上图的传输步骤：<br>client：我想要下一个数据包的编号是1，长度是360个字节  </p><p>server：数据给你，下个数据包的编号是361，我的发送窗口最大是120bytes  </p><p>client：我想要下一个数据包编号是361，长度是120个字节（按照你的要最大限度）  </p><p>server：数据给你，下个数据包的编号是481，我的发送窗口最大是120bytes  </p><p>…  </p><blockquote><p>我自己总结了一下SEQ和ACK的含义：<br><strong>SEQ是我这次要从哪个编号开始要数据；ACK是我下次要从哪个编号开始给数据</strong></p></blockquote><h5 id="5-数据包丢失处理"><a href="#5-数据包丢失处理" class="headerlink" title="5.数据包丢失处理"></a>5.数据包丢失处理</h5><p>TCP协议可以保证数据通信的完整性，这是怎么做到的？<br>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么ACK的编号就不会发生变化。  </p><p>举例来说，现在收到了4号包，但是没有收到5号包。ACK就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮ACK会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么ACK里面的编号不会变化，总是显示5号包。这会导致大量重复内容的ACK。<br>如果发送方发现收到三个连续的重复ACK，或者超时了还没有收到任何ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP保证了不会有数据包丢失。  </p><p><img src="./assets/tcp_lost.png" alt="">  </p><blockquote><p>hostB没有收到100-120这段编号的数据包，会重复发ACK=100，触发hostA重发数据包</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/05/20/seccloud_third/"/>
      <url>/2018/05/20/seccloud_third/</url>
      
        <content type="html"><![CDATA[<h2 id="8-关于Express应用项目实践"><a href="#8-关于Express应用项目实践" class="headerlink" title="8.关于Express应用项目实践"></a>8.关于Express应用项目实践</h2><p>上面说了很多概念性的内容，这部分就针对这次项目来说具体应用。这次后台整体下移，也就是从之前写java的portal层接口下移到对接设备的core层接口，出于安全性考虑，前台不能直接访问core层接口，需要用node在中间连接（认证部分这次用的casClient后面再细说）。主要的三个需求是接口转发、静态资源挂载，还有个服务器端口跳转；下面我会针对这三个需求说一下实现的过程吧 : )</p><p>这是主要require的几个模块：</p><pre><code class="javascript">var express = require(&#39;express&#39;)var proxy = require(&#39;http-proxy-middleware&#39;)var request = require(&#39;request&#39;)var bodyParser = require(&#39;body-parser&#39;)var path = require(&#39;path&#39;)var history = require(&#39;connect-history-api-fallback&#39;)</code></pre><h3 id="1-接口转发"><a href="#1-接口转发" class="headerlink" title="1.接口转发"></a>1.接口转发</h3><p>这部分是node实现的最基本要求，即前台调用express定义的前台接口，再由中间件向core层调用对应的接口取数据。</p><pre><code class="javascript">// 前台调用接口this.$axios({    method: &#39;GET&#39;,    url: &#39;http://127.60.0.1:3000/yuhui&#39;}).then(r=&gt;{    console.log(r.data)})//express捕获到做匹配var app = express()app.use(&#39;/yuhui&#39;, function(req,res,next){    // 向core层请求数据    res.jsonp(obj) // 返回给前台})app.listen(3000,&#39;127.60.0.2&#39;)</code></pre><h3 id="2-静态资源挂载"><a href="#2-静态资源挂载" class="headerlink" title="2.静态资源挂载"></a>2.静态资源挂载</h3><p>这个需求是为了用docker容器集成到主系统时，为了减少对接模块调试方便（vue+node+nginx到vue+node），就对前端的静态资源调用放到express来做。挂载静态资源是针对于build之后用于生产环境下的dist文件夹资源的调用，而不是开发环境的入口html，这个要注意哈！</p><pre><code class="javascript">app.use(express.static(&#39;../dist&#39;))app.listen(3000,&#39;127.60.0.2&#39;) //浏览器访问127.60.0.2:3000就可以访问项目了</code></pre><p>这样挂载的项目路径中会带有一个#，这是因为router默认采用hash模式，因此要对router做一下修改：</p><pre><code class="javascript">export default new Router({  mode: &#39;history&#39;, //修改路由模式  routes: [    {        path: &#39;/&#39;,        component: Index    },{        path: &#39;/content/:id&#39;,        component: Content    },{        path: &#39;/viewPage&#39;,        component: ViewPage    }  ]})</code></pre><p>但是这样做又会带来一个问题，这样的访问是针对于文件夹的静态资源路径而不是我们在开发环境中做的路由路径，会匹配不到资源返回404；所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面（也就是从主页面重进再按照路由的路径显示页面），这个页面就是你 app 依赖的页面。当然这个要自己写一个node处理的中间件可以，不过npm这么好的社区不用就很浪费: )</p><blockquote><p>npm install –save connect-history-api-fallback，<a href="https://github.com/bripkens/connect-history-api-fallback" target="_blank" rel="noopener">源码</a>在github上，有兴趣的同学可以去研究下，然后express可以以第三方中间件的形式使用，很方便。这里在附上官网的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">其他解决办法</a>，assetsPublicPath路径<a href="https://www.cnblogs.com/resolvent/p/5736678.html" target="_blank" rel="noopener">配置解释</a></p></blockquote><pre><code class="javascript">var history = require(&#39;connect-history-api-fallback&#39;)app.use(history()) //注意顺序！这个中间件的使用要放在挂载静态资源之前build: {  // Template for index.html    index: path.resolve(__dirname, &#39;../dist/index.html&#39;),  // Paths    assetsRoot: path.resolve(__dirname, &#39;../dist&#39;),    assetsSubDirectory: &#39;static&#39;,    assetsPublicPath: &#39;/&#39;,      //因为history默认会修改根目录，未配置前是相对路径；所以在webpack build命令配置需要修改成&#39;/&#39;，保证根目录不变，具体解释点上面链接}</code></pre><h3 id="3-服务器端口跳转"><a href="#3-服务器端口跳转" class="headerlink" title="3.服务器端口跳转"></a>3.服务器端口跳转</h3><p>这个需求呢是我撸码的时候自己提的= =使用环境就是服务器的一个端口挂了，可以跳转到另一个端口，相当于备用；利用http-proxy-middleware模块起一个代理服务器，用于转发端口或者IP+端口。</p><pre><code class="javascript">var proxy = require(&#39;http-proxy-middleware&#39;)app.use(&#39;/yuhui&#39;, proxy({    target: &#39;http://127.60.0.2:1234&#39;,    changeOrigen: true,    onProxyRes: function(proxyRes,req,res){        res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);          res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With, content-type&quot;);          res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);          res.header(&quot;X-Powered-By&quot;,&#39; 3.2.1&#39;)          res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);      },    cookieDomainRewrite: &#39;&#39; // 修改响应信息中的cookie域名，可以为false}))app2.use(&#39;/yuhui&#39;, function(req,res,next){    res.send(&#39;yuhui&#39;)})app.listen(3000,&#39;127.60.0.2&#39;) // 代理服务器端口app2.listen(1234,&#39;127.60.0.2&#39;)</code></pre><p>做完这几个需求，感触比较深的是：基于node开发要有一种模块化和社区的概念，这样无论是执行效率还是开发效率都会有很高的提升。（模块引用和中间件加载太舒服了~）</p><h2 id="9-基于casServer的登录认证"><a href="#9-基于casServer的登录认证" class="headerlink" title="9.基于casServer的登录认证"></a>9.基于casServer的登录认证</h2><h3 id="1-cas-server-cas-client-单点登录原理介绍"><a href="#1-cas-server-cas-client-单点登录原理介绍" class="headerlink" title="1.cas server + cas client 单点登录原理介绍"></a>1.cas server + cas client 单点登录原理介绍</h3><p>为了集成到cloudOS系统上需要对现在的项目做单点登录（保持单账号登录所有系统），打算用casServer做单点登录和权限控制以及用docker部署，关于docker的部分我后面研究完了在写上来吧:)<br>从结构上看，CAS 包含两个部分： CAS Server 和 CAS Client。CAS Server需要独立部署，主要负责对用户的认证工作；CAS Client负责处理对客户端受保护资源的访问请求，需要登录时，重定向到 CAS Server。</p><h4 id="CAS基础协议"><a href="#CAS基础协议" class="headerlink" title="CAS基础协议"></a>CAS基础协议</h4><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/casServer1.jpg" alt=""></p><h4 id="CAS的详细登录流程"><a href="#CAS的详细登录流程" class="headerlink" title="CAS的详细登录流程"></a>CAS的详细登录流程</h4><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/casServer2.jpg" alt=""></p><blockquote><p>关于cas的详细介绍，我也是从这两篇文章上了解的：<a href="https://blog.csdn.net/feng27156/article/details/38060099" target="_blank" rel="noopener">CAS基础协议</a>和<a href="http://htmlwww.cnblogs.com/lihuidu/p/6495247.html" target="_blank" rel="noopener">CAS的详细流程</a></p></blockquote><h3 id="2-配置介绍"><a href="#2-配置介绍" class="headerlink" title="2.配置介绍"></a>2.配置介绍</h3><p>这次项目呢，我主要做的就是casClient部分的逻辑，作为客户端和casServer的中间件，在不同情况下的重定向操作对于系统正常运行有很大影响，但考虑到客户端、casClient和casServer之间的数据交换和本地ticket验证等复杂的逻辑，可以考虑用npm安装合适的基于node的casClient，再做一些基本的配置即可。</p><blockquote><p>这次用的是connect-cas2模块，npm官网上的<a href="https://www.npmjs.com/package/connect-cas2" target="_blank" rel="noopener">配置</a>介绍是英文的，看着不太方便，附上<a href="https://github.com/TencentWSRD/connect-cas2/blob/master/README.zh.md" target="_blank" rel="noopener">中文版</a>的吧，这里列出几个比较重要的属性：</p></blockquote><pre><code class="javascript">var ConnectCas = require(&#39;connect-cas2&#39;)var casClient = new ConnectCae({    servicPrefix: // 网站根目录    serverPath: // casServer根路径，会和paths.serviceValidate拼接成casServer校验ticket路径    paths: {        validate: // 用于Client端校验ST路径，就是cas-connect2这个模块本地验证ST的js文件        serviceValidate: // 用于casServer校验ticket路径        login: // 会和serverPath拼接组成CAS的登录页面        logout: // 注销路径        ...    }    ...})app.use(casClient.core()) // 顺序要在bodyPaser之前</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/05/08/seccloud_second/"/>
      <url>/2018/05/08/seccloud_second/</url>
      
        <content type="html"><![CDATA[<h2 id="6-项目结构"><a href="#6-项目结构" class="headerlink" title="6.项目结构"></a>6.项目结构</h2><p>这部分应该是在刚开始写的，但忘了= =，现在补上吧。<br>在说这次项目之前先说基于vue-cli搭建的项目结构各个文件的作用，我就从csdn上找了篇文章（<a href="https://blog.csdn.net/qq_34543438/article/details/72868546?locationNum=3&fps=1" target="_blank" rel="noopener">点击此处</a>）。光看这些个概念可能有点抽象，结合这次项目我用自己的理解解释一下；这次用的是嵌套显示，主要通过路由里的children属性设置，具体配置如下：</p><h3 id="1-入口html文件（index-html）"><a href="#1-入口html文件（index-html）" class="headerlink" title="1.入口html文件（index.html）"></a>1.入口html文件（index.html）</h3><pre><code class="bash">&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;&lt;div id=&#39;version&#39;&gt;...&lt;/div&gt; &lt;!-- 检查浏览器版本 --&gt;</code></pre><h3 id="2-入口js文件（main-js）"><a href="#2-入口js文件（main-js）" class="headerlink" title="2.入口js文件（main.js）"></a>2.入口js文件（main.js）</h3><pre><code class="javascript">new Vue({    el: &#39;#app&#39;,    router, // 引用router文件夹index.js    components: {App}, // 入口vue文件    template: &#39;&lt;App/&gt;&#39;, // 模板将会替换挂载的元素，挂载元素的内容都将被忽略（看下面注释）    store: VuexStore // vuex原型})</code></pre><blockquote><p>注释：也就是说:template: ‘&lt;App/&gt;’ 表示用&lt;app&gt;&lt;/app&gt;替换index.html里面的&lt;div id=”app”&gt;&lt;/div&gt;</p></blockquote><h3 id="3-入口vue文件（App-vue）"><a href="#3-入口vue文件（App-vue）" class="headerlink" title="3.入口vue文件（App.vue）"></a>3.入口vue文件（App.vue）</h3><pre><code class="javascript">&lt;template&gt;    &lt;div id=&#39;app&#39;&gt;        &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 路由视图组件 --&gt;    &lt;/div&gt;&lt;template&gt;</code></pre><h3 id="4-主路由（router-index-js）"><a href="#4-主路由（router-index-js）" class="headerlink" title="4.主路由（router/index.js）"></a>4.主路由（router/index.js）</h3><p>这次项目基于上面的<router-view>渲染分两个VUE文件：login.vue和Main.vue，下面会对这两个VUE文件做具体介绍。</p><pre><code class="javascript">//登录页面路由信息const loginRouter = {    path:    name:    component: () =&gt; import(...)}//业务页面路由信息，都是挂载在Main.vue页面里，等同于入口vue的&lt;router-view&gt;const defindeRouter = { // 错误跳转页面路由    path:    name:    component: Main // import Main from ...引入Main组件，设置children属性设置业务页面路由    children: [{...}]}const topbarRouter = { // top栏路由    path:    name:    component: Main    children: [{...}]}const sidebarRouter = [ // 具体各个业务页面路由    {        path:        name:        component: Main        children: [{...}]    },    {        path:        name:        component: Main        children: [{...}]    }]export const routerConfig = [    loginRouter,    topbarRouter,    defindeRouter,    ...sidebarRouter // 解构]//导出路由信息，在App.vue文件中引入</code></pre><h3 id="5-Main-vue（业务页面都挂载在下面）"><a href="#5-Main-vue（业务页面都挂载在下面）" class="headerlink" title="5.Main.vue（业务页面都挂载在下面）"></a>5.Main.vue（业务页面都挂载在下面）</h3><pre><code class="bash">&lt;template&gt;    &lt;Header&gt;&lt;/Header&gt;    &lt;Content&gt;        &lt;router-view&gt;&lt;/router-view&gt; // 联系上面的children路由信息，都通过这个路由视图显示    &lt;/Content&gt;    &lt;Footer&gt;&lt;/Footer&gt;&lt;/template&gt;</code></pre><p>综上所述，所有页面都显示在入口index.html的&lt;div id=’app’&gt;里，main.js创建VUE实例，login和Main作为两个主vue文件，通过App.vue文件的&lt;router-view&gt;路由视图显示，业务页面通过Main.vue的&lt;router-view&gt;的路由视图显示，利用路由children属性把页面挂载在Main.vue上。</p><h2 id="7-路由分发"><a href="#7-路由分发" class="headerlink" title="7.路由分发"></a>7.路由分发</h2><pre><code class="javascript">/*    Apache请求数据库的代码*/res = db.query(&#39;SELECT * from some_table&#39;)res.output()/*    Nodejs请求数据库的代码*/db.query(&#39;SELECT * from some_table&#39;, function(res){    res.output()})</code></pre><p>由于项目开发的深入，为了配合设备层的配置下发，后台开始着手core层的接口，也就是说不完全针对页面显示的数据接口；这种情况下需要前台对接口进行路由分发，对于后台给出的接口改构和包装，达到页面显示需要的数据结构的接口，这次用的是nodejs的express框架，在应用到项目前，这里算是学习笔记和感想。</p><p>一个基本的express应用的结构：</p><pre><code class="javascript">var express = require(&#39;express&#39;) // 安装node的时候回自动安装expressvar app = express()app.get(&#39;/&#39;, (req,res) =&gt; { // req(请求)和res(响应)与Node提供的对象完全一致    res.send(&#39;监听3030端口进入的所有get请求&#39;)        })var server = app.listen(3030, function{    var host = server.address().address      var port = server.address().port      console.log(&#39;Example app listening at http://%s:%s&#39;, host, port)})</code></pre><h3 id="1-基本路由和静态文件挂载"><a href="#1-基本路由和静态文件挂载" class="headerlink" title="1.基本路由和静态文件挂载"></a>1.基本路由和静态文件挂载</h3><p>常见的4个基本http请求：</p><pre><code class="javascript">// 对网站首页的访问返回 &quot;Hello World!&quot; 字样app.get(&#39;/&#39;, function (req, res) {  res.send(&#39;Hello World!&#39;);});// 网站首页接受 POST 请求app.post(&#39;/&#39;, function (req, res) {  res.send(&#39;Got a POST request&#39;);});// /user 节点接受 PUT 请求app.put(&#39;/user&#39;, function (req, res) {  res.send(&#39;Got a PUT request at /user&#39;);});// /user 节点接受 DELETE 请求app.delete(&#39;/user&#39;, function (req, res) {  res.send(&#39;Got a DELETE request at /user&#39;);});</code></pre><p>利用express托管静态文件（express.static中间件）</p><pre><code class="javascript">app.use(express.static(&#39;public&#39;))// 通过http://localhost:3030/image/xx.png访问// 多个目录按照添加顺序查找app.use(&#39;/public&#39;, express.static(&#39;public&#39;))// 存放虚拟目录，通过指定的挂载路径访问：http://localhost:3030/public/image/xx.png</code></pre><h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h3><p>路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。<br>路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。</p><pre><code class="javascript">// 对于上面的4种请求的句柄改用app.route()定义链式句柄app.route(&#39;/public&#39;)    .get((req,res) =&gt; {        ...    })    .post((req,res) =&gt; {        ...    })    .put((req,res) =&gt; {        ...    });// 监听来自/public的所有请求app.all(&#39;/public&#39;, function(req,res,next){    ...    next();})// 路由匹配// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res) {      res.send(&#39;/.*fly$/&#39;);});</code></pre><h4 id="express-Router"><a href="#express-Router" class="headerlink" title="express.Router"></a>express.Router</h4><p>调用express()方法创建的Application(app)内部都创建了一个Router，大部分对 Application 的操作实际上都被重定向到了这个内部的Router上而已。而Application所做的，只不过是在这个Router的基础上添加了一些额外的便捷 API 而已。</p><pre><code class="javascript">var express = require(&#39;express&#39;);var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) {  console.log(&#39;Time: &#39;, Date.now());  next();});// 定义网站主页的路由router.get(&#39;/&#39;, function(req, res) {  res.send(&#39;Birds home page&#39;);});// 定义 about 页面的路由router.get(&#39;/about&#39;, function(req, res) {  res.send(&#39;About public&#39;);});module.exports = router;// 在应用中加载路由模块var pub = require(&#39;js文件路径&#39;);...app.use(&#39;/public&#39;, pub);// 应用即可处理发自 /public 和 /public/about 的请求，并且调用为该路由指定的 timeLog 中间件</code></pre><h3 id="3-中间件"><a href="#3-中间件" class="headerlink" title="3.中间件"></a>3.中间件</h3><p>中间件（Middleware）是一个函数，它可以访问请求对象（request object (req)），响应对象（response object (res)），和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。</p><blockquote><p>关于next()函数的解释，我找了一篇比较好的<a href="http://cnodejs.org/topic/5757e80a8316c7cb1ad35bab" target="_blank" rel="noopener">文章</a></p></blockquote><p>中间件的功能包括：</p><ul><li>执行任何代码；</li><li>修改请求和响应对象；</li><li>终结请求-响应循环；</li><li>调用堆栈中的下一个中间件。<br>如果当前中间件没有终结请求-响应循环，则必须调用 next()方法将控制权交给下一个中间件，否则请求就会挂起。</li></ul><p>Express 应用可使用如下几种中间件：</p><ul><li>应用级中间件</li><li>路由级中间件</li><li>错误处理中间件</li><li>内置中间件</li><li>第三方中间件</li></ul><h4 id="1-应用级中间件"><a href="#1-应用级中间件" class="headerlink" title="1.应用级中间件"></a>1.应用级中间件</h4><p>应用级中间件绑定到<strong>app对象</strong>使用app.use()和app.METHOD()，其中METHOD是需要处理的HTTP请求的方法，例如GET, PUT, POST 等等，全部小写。例如：</p><pre><code class="javascript">var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) {  console.log(&#39;Time:&#39;, Date.now());  next();});// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use(&#39;/user/:id&#39;, function (req, res, next) {  console.log(&#39;Request Type:&#39;, req.method);  next();});// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get(&#39;/user/:id&#39;, function (req, res, next) {  res.send(&#39;USER&#39;);});</code></pre><p>下面这个例子展示了在一个挂载点装载一组中间件。</p><pre><code class="javascript">// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息app.use(&#39;/user/:id&#39;, function(req, res, next) {  console.log(&#39;Request URL:&#39;, req.originalUrl);  next();}, function (req, res, next) {  console.log(&#39;Request Type:&#39;, req.method);  next();});</code></pre><p>作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了<strong>两个路由</strong>。第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。</p><pre><code class="javascript">// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get(&#39;/user/:id&#39;, function (req, res, next) {  console.log(&#39;ID:&#39;, req.params.id);  next();}, function (req, res, next) {  res.send(&#39;User Info&#39;);});// 处理 /user/:id， 打印出用户 idapp.get(&#39;/user/:id&#39;, function (req, res, next) {  res.end(req.params.id);});</code></pre><p>如果需要在中间件栈中跳过剩余中间件，调用 next(‘route’) 方法将控制权交给下一个路由。 注意： next(‘route’) 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。</p><pre><code class="javascript">// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get(&#39;/user/:id&#39;, function (req, res, next) {  // 如果 user id 为 0, 跳到下一个路由  if (req.params.id == 0) next(&#39;route&#39;);  // 否则将控制权交给栈中下一个中间件  else next(); //}, function (req, res, next) {  // 渲染常规页面  res.render(&#39;regular&#39;);});// 处理 /user/:id， 渲染一个特殊页面app.get(&#39;/user/:id&#39;, function (req, res, next) {  res.render(&#39;special&#39;);});</code></pre><h4 id="2-路由级中间件"><a href="#2-路由级中间件" class="headerlink" title="2.路由级中间件"></a>2.路由级中间件</h4><p>路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。</p><pre><code class="javascript">var router = express.Router();</code></pre><p>路由级使用 router.use() 或 router.VERB() 加载。<br>上述在应用级创建的中间件系统，可通过如下代码改写为路由级：</p><pre><code class="javascript">var app = express();var router = express.Router();// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件router.use(function (req, res, next) {  console.log(&#39;Time:&#39;, Date.now());  next();});// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use(&#39;/user/:id&#39;, function(req, res, next) {  console.log(&#39;Request URL:&#39;, req.originalUrl);  next();}, function (req, res, next) {  console.log(&#39;Request Type:&#39;, req.method);  next();});// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get(&#39;/user/:id&#39;, function (req, res, next) {  // 如果 user id 为 0, 跳到下一个路由  if (req.params.id == 0) next(&#39;route&#39;);  // 负责将控制权交给栈中下一个中间件  else next(); //}, function (req, res, next) {  // 渲染常规页面  res.render(&#39;regular&#39;);});// 处理 /user/:id， 渲染一个特殊页面router.get(&#39;/user/:id&#39;, function (req, res, next) {  console.log(req.params.id);  res.render(&#39;special&#39;);});// 将路由挂载至应用app.use(&#39;/&#39;, router);</code></pre><blockquote><p>路由级中间件和非路由级中间件的第三个参数next不是同一个next，功能上基本相同。</p></blockquote><h4 id="3-错误处理中间件"><a href="#3-错误处理中间件" class="headerlink" title="3.错误处理中间件"></a>3.错误处理中间件</h4><blockquote><p>错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这4个参数（4个参数是next(err)执行判断的标识）。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p></blockquote><pre><code class="javascript">app.use(function(err, req, res, next) {  console.error(err.stack);  res.status(500).send(&#39;Something broke!&#39;);});</code></pre><p>具体关于错误处理中间件的介绍可以参考<a href="http://www.expressjs.com.cn/guide/error-handling.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="4-内置中间件"><a href="#4-内置中间件" class="headerlink" title="4.内置中间件"></a>4.内置中间件</h4><p>express.static是Express唯一的内置中间件。它基于serve-static，负责在Express应用中托管静态资源。<br>最常用的用法在上面已经介绍过了，关于更细节的参数可参考<a href="http://www.expressjs.com.cn/guide/using-middleware.html#middleware.built-in" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/04/08/seccloud/"/>
      <url>/2018/04/08/seccloud/</url>
      
        <content type="html"><![CDATA[<h2 id="by-2019-8-14-14-15"><a href="#by-2019-8-14-14-15" class="headerlink" title="by 2019/8/14 14:15"></a>by 2019/8/14 14:15</h2><p>这个项目是在新华三的第一个Vue开发的项目，也因为最近有了更好的选择，所以呢这部分的更新就到此为止了，后面的仓库会基于新公司新项目写开发和学习日常，估计到时候就不是vue了= =应该是react吧，有点方Orz</p><h2 id="by-2019-3-16-15-00"><a href="#by-2019-3-16-15-00" class="headerlink" title="by 2019/3/16 15:00"></a>by 2019/3/16 15:00</h2><p>今天加班等测试提问题单，空了点时间整理了一下这里的readme.md，都已经按照分类放到Issues和project里了，更清晰明了一点。有什么意见可以在Issues下评论，多谢Orz</p><h2 id="by-2019-3-1-09-40"><a href="#by-2019-3-1-09-40" class="headerlink" title="by 2019/3/1 09:40"></a>by 2019/3/1 09:40</h2><p>emmmmm 项目已经一期做完了，二期做了一半吧，自我感觉我的业务代码写了有这个项目的1/4到1/3之间吧（项目组总共有9个人= =），代码量差不多有30k了，还是很心累的；从一开始的框架搭建到nodejs（express）的引入再到前端vue-router的权限管理，自我感觉已经做的挺不错了。后面就写写比如vuex、es6概念方面的理解吧，不能只知道用，还是要熟悉一些属性、方法什么的。  </p><h2 id="by-2018-4-8-11-00"><a href="#by-2018-4-8-11-00" class="headerlink" title="by 2018/4/8 11:00"></a>by 2018/4/8 11:00</h2><p>emmmmm 今年2月1号开始的安全SASS云项目在上个月（3月31号）也结束第一次的发布会检查，总体上来说还是挺不错的吧，2个月的时间前端部分完成了95%，和后台的联调完成的不多，大概也就70%吧= =实在是页面太多了，一个完整的SASS云项目为了达到发布会的要求，从没有成熟的UI设计和业务实现逻辑到各功能模块的实现用了大概一个半月的时间，后面花了半个月左右的时间联调。总的页面总共加起来数量大概有将近100各左右，我负责了大概其中的20个页面吧：包含LB、NAT、用户信息等等的主页、配置页和详情页，31号晚上提交代码后闲下来无聊数了一下前前后后业务代码、封装模块组件的代码差不多有个1w行吧T T虽然这中间加班了很多次，也有发布会前一晚通宵，但还是有很多收获的吧 :)</p><p>这次项目用的主要是VUE框架基于webpack、es6和node开发的环境，其中为了快速开发吧，用了一些iview的组件，自己也在iview提供的基础组件的基础上封装了几个功能性更强的组件。对于这次项目的总结我会每天写一点，当做记录吧，项目结束我会整理成几篇博文放到我的博客去。</p><h2 id="1-路由（router）"><a href="#1-路由（router）" class="headerlink" title="1.路由（router）"></a>1.路由（router）</h2><p>在说项目路由前，可以先看看vue官方给出的<a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">vue-router</a>的介绍，我也会列出一些稍微需要注意的点：</p><h3 id="1-动态路由参数"><a href="#1-动态路由参数" class="headerlink" title="1.动态路由参数"></a>1.动态路由参数</h3><p>用于不同ID的用户都需使用同一个组件渲染</p><pre><code class="javascript">const User = {  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;}const router = new VueRouter({  routes: [    // 动态路径参数 以冒号开头    { path: &#39;/user/:id&#39;, component: User }  ]})</code></pre><blockquote><p>像 /user/foo 和 /user/bar 都将映射到相同的路由。一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。其中params靠this.$router.push(name or path, params: {id: xx})方法传递，也可以多段设置路由参数：模式:/user/: username/post/:post_id =&gt; 匹配路径: /user/evan/post/123 =&gt; $route.params: { username: ‘evan’, post_id: 123 }</p></blockquote><h3 id="2-结合项目"><a href="#2-结合项目" class="headerlink" title="2.结合项目"></a>2.结合项目</h3><p>这次采用的是分级的路由定义方式：</p><pre><code class="javascript">import childRouter from &#39;../../router&#39;const parentPouter1 = {    path:    name:    title:    component:    children: childRouter}const routerConfig = [ parentPouter1 ]export default const router = new VueRouter({    routes: routerConfig})// 再在childRouter里面分级定义子路由：[    {        path:        name:        title:        component: () =&gt; import(&#39;url&#39;) //具体页面的路径    },    {        path:        name:        title:        component: () =&gt; import(&#39;url&#39;) //具体页面的路径    }]</code></pre><p>对于手风琴类的父级展开式的多个子路由的情况：</p><pre><code class="javascript">const parentPouter2 = [    {        path:        name:        title:        component:        children: childRouter1    },    {        path:        name:        title:        component:        children: childRouter2    }]const routerConfig = [     parentRouter1,    ...parentPouter2  //...分构数组成对象形式的路由]export default const router = new VueRouter({    routes: routerConfig})</code></pre><p>具体关于项目路由结构可以看第6项介绍。</p><h2 id="2-封装组件"><a href="#2-封装组件" class="headerlink" title="2.封装组件"></a>2.封装组件</h2><p>在三月中旬开发的时候，被要求在主要业务的主页上添加一个详情的可收缩的弹框。需求很简单，但为了统一样式便于开发，采取了单独封装组件的方式。其中为了保证详情框和主页面内容高度一致，用到CSS变量的知识点（具体内容可以阅读<a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html" target="_blank" rel="noopener">阮一峰CSS变量教程</a>）。</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;    mounted () {        document.body.style.setProperty(&#39;--autoHeight&#39;, $(#leftId).height()) // 取到左边内容高度再设置autoHeight变量的大小    }&lt;/script&gt;&lt;style type=&#39;text/css&#39; scoped&gt;    body {        --autoHeught: 25; /*这个高度是随便定的，表示类型即可*/    }    .card {        height: calc(var(--autoHeight)*1px); //var()函数是取css变量的值；calc()函数连接数值和单位    }&lt;/style&gt;</code></pre><h2 id="3-数据传递"><a href="#3-数据传递" class="headerlink" title="3.数据传递"></a>3.数据传递</h2><p>VUE框架中可以用动态路由在不同页面间传递数据，常用的传递参数的方法是通过params和query，注意的是：由于动态路由也是传递params的，所以在 this.$router.push() 方法中path不能和params一起使用，否则params将无效。需要用name来指定页面</p><h3 id="1-params"><a href="#1-params" class="headerlink" title="1.params"></a>1.params</h3><pre><code class="javascript">this.$router.push({name:&#39;RouterName&#39;, params:{data: this.userID}}) //其中name参数是下一跳路由的name属性// 在目的页面使用传递过来的params里的data值this.$route.params.data</code></pre><h3 id="2-query"><a href="#2-query" class="headerlink" title="2.query"></a>2.query</h3><pre><code class="javascript">this.$router.push({name:&#39;RouterName&#39;, query:{data: this.userID}}) //其中name参数是跳转路由的name属性// 或者this.$router.push({path:&#39;RouterPath&#39;, query:{data: this.userID}}) //其中path参数是下一跳路由的path属性// 在目的页面使用传递过来的query里的data值this.$route.query.data</code></pre><p>这两种传递参数的方法区别主要在于：params传递的参数不会体现在页面的URL里，刷新页面后数据就会消失；query传递的参数会以”?userID=xxx”的后缀方式体现在URL中，刷新页面数据还会保留。</p><h2 id="4-父子组件通信"><a href="#4-父子组件通信" class="headerlink" title="4.父子组件通信"></a>4.父子组件通信</h2><p>在单个页面里的组件间的通信，例如打开新建或编辑框时的数据传递；这里只考虑父子组件间的通信，非父子组件通信通过创建事件中心的方式暂不深究。</p><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/dataConmmunicate.png" alt=""></p><h3 id="1-父组件传递数据给子组件"><a href="#1-父组件传递数据给子组件" class="headerlink" title="1.父组件传递数据给子组件"></a>1.父组件传递数据给子组件</h3><p>主要通过props属性实现：</p><pre><code class="vue">//父组件&lt;parent&gt;    &lt;child :childprops=&#39;this.data&#39;&gt;&lt;child&gt;&lt;/parent&gt;&lt;script&gt;    data () {        return {            data: &#39;mclean&#39;        }    }&lt;/script&gt;//子组件props: [&#39;childprops&#39;]//或者props: {    childprops: String // 这样可以指定传入的类型，如果类型不对，会警告}//再者props: {    childprops: {        type: Array,        default: &#39;yuhui&#39; // 这样可以指定默认的值    }}</code></pre><p>子组件注册一个属性（props）childprops，父组件中对这个属性绑定值，子组件可以直接this.childprops调用父组件传过来的数据。</p><h3 id="2-子组件向父组件传递"><a href="#2-子组件向父组件传递" class="headerlink" title="2.子组件向父组件传递"></a>2.子组件向父组件传递</h3><p>子组件想要改变数据这在VUE里面是不允许的，因为VUE只允许单向数据传递，我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的，即拿到子组件传过来的数据。</p><pre><code class="vue">//子组件&lt;template&gt;    &lt;button @click=&#39;buttonClick&#39;&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script&gt;    methods: {        buttonClick () {            this.$emit(&#39;childMethod&#39;, childData); // 触发childMethod,传递参数childData        }    }&lt;/script&gt;//父组件&lt;parent&gt;    &lt;child v-on:childMethod=&#39;parentMethod&#39;&gt;&lt;/child&gt;&lt;/parent&gt;&lt;script&gt;    methods: {        parentMethod (data) {            // 参数data即子组件传递的childData        }    }&lt;/script&gt;</code></pre><p>this.$emit()监听触发childMethod方法，通知父组件执行parentMethod方法,并拿到参数。</p><h2 id="5-状态管理"><a href="#5-状态管理" class="headerlink" title="5.状态管理"></a>5.状态管理</h2><p>针对这次项目，有个直观的感受就是：数据在组件间通信比较频繁的情况下，通常用的父子组件、兄弟组件通信方式就会显得异常繁琐，而且不便于管理。<br>从VUE一个简单的状态自管理应用来看：</p><pre><code class="vue">new Vue({  // state  data () {    return {      count: 0    }  },  // view  template:    &lt;div&gt;{{ count }}&lt;/div&gt;  // actions  methods: {    increment () {      this.count++    }  }})</code></pre><p>这个状态自管理应用包含以下几个部分：</p><ul><li>state：驱动应用的数据源；</li><li>view：以声明方式将state映射到视图；</li><li>actions：响应在 view上的用户输入导致的状态变化。</li></ul><p>这是一个普通的组件从样式渲染到数据绑定再到数据变化，单一的状态比较清晰，遇到多个组件共享状态时，这种简洁性很容易被破坏且难以管理。因此，把组件的共享状态抽出来，以一个全局单例模式管理，这就是VUEX背后的基本思想。</p><p><img src="https://cdn.jsdelivr.net/gh/alexandermclean/cdn@5.0/img/assets/vuex.png" alt=""></p><p>后续用完之后再来写: )</p>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 安全云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步调用</title>
      <link href="/2018/01/08/async&amp;promise/"/>
      <url>/2018/01/08/async&amp;promise/</url>
      
        <content type="html"><![CDATA[<h2 id="异步组合使用"><a href="#异步组合使用" class="headerlink" title="异步组合使用"></a>异步组合使用</h2><pre><code class="javascript">function sleep(duration){    return new Promise(function(resolve){        setTimeout(resolve, duration);    })}async function changeColor(duration,color){    document.getElementById(&quot;traffic-light&quot;).style.background = color;    await sleep(duration);}async function main(){    while(true){        await changeColor(3000,&quot;green&quot;);        await changeColor(1000, &quot;yellow&quot;);        await changeColor(2000, &quot;red&quot;);    }}main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容易忘的用法</title>
      <link href="/2018/01/08/basic/"/>
      <url>/2018/01/08/basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-代码托管"><a href="#1-代码托管" class="headerlink" title="1.代码托管"></a>1.代码托管</h2><p>基于gitLab的代码版本管理，简单的写下流程吧</p><ol><li>git clone 项目远程主机路径/git clone -b 具体分支 项目远程主机；会有一个默认的remote叫做origin</li><li>git remote add xxx（自己的远程主机名） 远程主机路径</li><li>git push xxx 本地分支名称:远程分支名称（没有分支名称时自动创建）</li><li>git fetch origin / git merge origin 分支名</li></ol><p>后续用到了再来写吧: )</p>]]></content>
      
      
      <categories>
          
          <category> 项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容易忘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
