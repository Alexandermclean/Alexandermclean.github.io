<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test_title</title>
      <link href="/2018/12/12/test/"/>
      <url>/2018/12/12/test/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">var a = &#39;b&#39;var b = &#39;a&#39;</code></pre><pre><code class="bash">var a = &#39;b&#39;var b = &#39;a&#39;</code></pre><pre><code class="html">&lt;div&gt;aaa&lt;/div&gt;</code></pre><pre><code class="yml">deploy:  type: git  repo:     github: 你的github仓库地址    # coding: 你的coding仓库地址  branch: master</code></pre><pre><code class="md">## ddas{% bili video_id [page] %}{% bili video_id [page] %}</code></pre>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 悦读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test2</title>
      <link href="/2018/11/12/test2/"/>
      <url>/2018/11/12/test2/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">var a = &#39;b&#39;var b = &#39;a&#39;</code></pre><pre><code class="bash">var a = &#39;b&#39;var b = &#39;a&#39;</code></pre><pre><code class="html">&lt;div&gt;aaa&lt;/div&gt;</code></pre><pre><code class="yml">deploy:  type: git  repo:     github: 你的github仓库地址    # coding: 你的coding仓库地址  branch: master</code></pre><pre><code class="md">## ddas{% bili video_id [page] %}{% bili video_id [page] %}</code></pre>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
            <tag> seccloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全云——H3C</title>
      <link href="/2018/04/08/seccloud/"/>
      <url>/2018/04/08/seccloud/</url>
      
        <content type="html"><![CDATA[<h2 id="by-2019-8-14-14-15"><a href="#by-2019-8-14-14-15" class="headerlink" title="by 2019/8/14 14:15"></a>by 2019/8/14 14:15</h2><p>这个项目是在新华三的第一个Vue开发的项目，也因为最近有了更好的选择，所以呢这部分的更新就到此为止了，后面的仓库会基于新公司新项目写开发和学习日常，估计到时候就不是vue了= =应该是react吧，有点方Orz</p><h2 id="by-2019-3-16-15-00"><a href="#by-2019-3-16-15-00" class="headerlink" title="by 2019/3/16 15:00"></a>by 2019/3/16 15:00</h2><p>今天加班等测试提问题单，空了点时间整理了一下这里的readme.md，都已经按照分类放到Issues和project里了，更清晰明了一点。有什么意见可以在Issues下评论，多谢Orz</p><h2 id="by-2019-3-1-09-40"><a href="#by-2019-3-1-09-40" class="headerlink" title="by 2019/3/1 09:40"></a>by 2019/3/1 09:40</h2><p>emmmmm 项目已经一期做完了，二期做了一半吧，自我感觉我的业务代码写了有这个项目的1/4到1/3之间吧（项目组总共有9个人= =），代码量差不多有30k了，还是很心累的；从一开始的框架搭建到nodejs（express）的引入再到前端vue-router的权限管理，自我感觉已经做的挺不错了。后面就写写比如vuex、es6概念方面的理解吧，不能只知道用，还是要熟悉一些属性、方法什么的。  </p><h2 id="by-2018-4-8-11-00"><a href="#by-2018-4-8-11-00" class="headerlink" title="by 2018/4/8 11:00"></a>by 2018/4/8 11:00</h2><p>emmmmm 今年2月1号开始的安全SASS云项目在上个月（3月31号）也结束第一次的发布会检查，总体上来说还是挺不错的吧，2个月的时间前端部分完成了95%，和后台的联调完成的不多，大概也就70%吧= =实在是页面太多了，一个完整的SASS云项目为了达到发布会的要求，从没有成熟的UI设计和业务实现逻辑到各功能模块的实现用了大概一个半月的时间，后面花了半个月左右的时间联调。总的页面总共加起来数量大概有将近100各左右，我负责了大概其中的20个页面吧：包含LB、NAT、用户信息等等的主页、配置页和详情页，31号晚上提交代码后闲下来无聊数了一下前前后后业务代码、封装模块组件的代码差不多有个1w行吧T T虽然这中间加班了很多次，也有发布会前一晚通宵，但还是有很多收获的吧 :)</p><p>这次项目用的主要是VUE框架基于webpack、es6和node开发的环境，其中为了快速开发吧，用了一些iview的组件，自己也在iview提供的基础组件的基础上封装了几个功能性更强的组件。对于这次项目的总结我会每天写一点，当做记录吧，项目结束我会整理成几篇博文放到我的博客去。</p><h2 id="1-路由（router）"><a href="#1-路由（router）" class="headerlink" title="1.路由（router）"></a>1.路由（router）</h2><p>在说项目路由前，可以先看看vue官方给出的<a href="https://router.vuejs.org/zh-cn/essentials/getting-started.html" target="_blank" rel="noopener">vue-router</a>的介绍，我也会列出一些稍微需要注意的点：</p><h3 id="1-动态路由参数"><a href="#1-动态路由参数" class="headerlink" title="1.动态路由参数"></a>1.动态路由参数</h3><p>用于不同ID的用户都需使用同一个组件渲染</p><pre><code class="javascript">const User = {  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;}const router = new VueRouter({  routes: [    // 动态路径参数 以冒号开头    { path: &#39;/user/:id&#39;, component: User }  ]})</code></pre><blockquote><p>像 /user/foo 和 /user/bar 都将映射到相同的路由。一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。其中params靠this.$router.push(name or path, params: {id: xx})方法传递，也可以多段设置路由参数：模式:/user/: username/post/:post_id =&gt; 匹配路径: /user/evan/post/123 =&gt; $route.params: { username: ‘evan’, post_id: 123 }</p></blockquote><h3 id="2-结合项目"><a href="#2-结合项目" class="headerlink" title="2.结合项目"></a>2.结合项目</h3><p>这次采用的是分级的路由定义方式：</p><pre><code class="javascript">import childRouter from &#39;../../router&#39;const parentPouter1 = {    path:    name:    title:    component:    children: childRouter}const routerConfig = [ parentPouter1 ]export default const router = new VueRouter({    routes: routerConfig})// 再在childRouter里面分级定义子路由：[    {        path:        name:        title:        component: () =&gt; import(&#39;url&#39;) //具体页面的路径    },    {        path:        name:        title:        component: () =&gt; import(&#39;url&#39;) //具体页面的路径    }]</code></pre><p>对于手风琴类的父级展开式的多个子路由的情况：</p><pre><code class="javascript">const parentPouter2 = [    {        path:        name:        title:        component:        children: childRouter1    },    {        path:        name:        title:        component:        children: childRouter2    }]const routerConfig = [     parentRouter1,    ...parentPouter2  //...分构数组成对象形式的路由]export default const router = new VueRouter({    routes: routerConfig})</code></pre><p>具体关于项目路由结构可以看第6项介绍。</p><h2 id="2-封装组件"><a href="#2-封装组件" class="headerlink" title="2.封装组件"></a>2.封装组件</h2><p>在三月中旬开发的时候，被要求在主要业务的主页上添加一个详情的可收缩的弹框。需求很简单，但为了统一样式便于开发，采取了单独封装组件的方式。其中为了保证详情框和主页面内容高度一致，用到CSS变量的知识点（具体内容可以阅读<a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html" target="_blank" rel="noopener">阮一峰CSS变量教程</a>）。</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;    mounted () {        document.body.style.setProperty(&#39;--autoHeight&#39;, $(#leftId).height()) // 取到左边内容高度再设置autoHeight变量的大小    }&lt;/script&gt;&lt;style type=&#39;text/css&#39; scoped&gt;    body {        --autoHeught: 25; /*这个高度是随便定的，表示类型即可*/    }    .card {        height: calc(var(--autoHeight)*1px); //var()函数是取css变量的值；calc()函数连接数值和单位    }&lt;/style&gt;</code></pre><h2 id="3-数据传递"><a href="#3-数据传递" class="headerlink" title="3.数据传递"></a>3.数据传递</h2><p>VUE框架中可以用动态路由在不同页面间传递数据，常用的传递参数的方法是通过params和query，注意的是：由于动态路由也是传递params的，所以在 this.$router.push() 方法中path不能和params一起使用，否则params将无效。需要用name来指定页面</p><h3 id="1-params"><a href="#1-params" class="headerlink" title="1.params"></a>1.params</h3><pre><code class="javascript">this.$router.push({name:&#39;RouterName&#39;, params:{data: this.userID}}) //其中name参数是下一跳路由的name属性// 在目的页面使用传递过来的params里的data值this.$route.params.data</code></pre><h3 id="2-query"><a href="#2-query" class="headerlink" title="2.query"></a>2.query</h3><pre><code class="javascript">this.$router.push({name:&#39;RouterName&#39;, query:{data: this.userID}}) //其中name参数是跳转路由的name属性// 或者this.$router.push({path:&#39;RouterPath&#39;, query:{data: this.userID}}) //其中path参数是下一跳路由的path属性// 在目的页面使用传递过来的query里的data值this.$route.query.data</code></pre><p>这两种传递参数的方法区别主要在于：params传递的参数不会体现在页面的URL里，刷新页面后数据就会消失；query传递的参数会以”?userID=xxx”的后缀方式体现在URL中，刷新页面数据还会保留。</p><h2 id="4-父子组件通信"><a href="#4-父子组件通信" class="headerlink" title="4.父子组件通信"></a>4.父子组件通信</h2><p>在单个页面里的组件间的通信，例如打开新建或编辑框时的数据传递；这里只考虑父子组件间的通信，非父子组件通信通过创建事件中心的方式暂不深究。</p><p><img src="../assets/dataConmmunicate.png" alt=""></p><h3 id="1-父组件传递数据给子组件"><a href="#1-父组件传递数据给子组件" class="headerlink" title="1.父组件传递数据给子组件"></a>1.父组件传递数据给子组件</h3><p>主要通过props属性实现：</p><pre><code class="vue">//父组件&lt;parent&gt;    &lt;child :childprops=&#39;this.data&#39;&gt;&lt;child&gt;&lt;/parent&gt;&lt;script&gt;    data () {        return {            data: &#39;mclean&#39;        }    }&lt;/script&gt;//子组件props: [&#39;childprops&#39;]//或者props: {    childprops: String // 这样可以指定传入的类型，如果类型不对，会警告}//再者props: {    childprops: {        type: Array,        default: &#39;yuhui&#39; // 这样可以指定默认的值    }}</code></pre><p>子组件注册一个属性（props）childprops，父组件中对这个属性绑定值，子组件可以直接this.childprops调用父组件传过来的数据。</p><h3 id="2-子组件向父组件传递"><a href="#2-子组件向父组件传递" class="headerlink" title="2.子组件向父组件传递"></a>2.子组件向父组件传递</h3><p>子组件想要改变数据这在VUE里面是不允许的，因为VUE只允许单向数据传递，我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的，即拿到子组件传过来的数据。</p><pre><code class="vue">//子组件&lt;template&gt;    &lt;button @click=&#39;buttonClick&#39;&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script&gt;    methods: {        buttonClick () {            this.$emit(&#39;childMethod&#39;, childData); // 触发childMethod,传递参数childData        }    }&lt;/script&gt;//父组件&lt;parent&gt;    &lt;child v-on:childMethod=&#39;parentMethod&#39;&gt;&lt;/child&gt;&lt;/parent&gt;&lt;script&gt;    methods: {        parentMethod (data) {            // 参数data即子组件传递的childData        }    }&lt;/script&gt;</code></pre><p>this.$emit()监听触发childMethod方法，通知父组件执行parentMethod方法,并拿到参数。</p><h2 id="5-状态管理"><a href="#5-状态管理" class="headerlink" title="5.状态管理"></a>5.状态管理</h2><p>针对这次项目，有个直观的感受就是：数据在组件间通信比较频繁的情况下，通常用的父子组件、兄弟组件通信方式就会显得异常繁琐，而且不便于管理。<br>从VUE一个简单的状态自管理应用来看：</p><pre><code class="vue">new Vue({  // state  data () {    return {      count: 0    }  },  // view  template:    &lt;div&gt;{{ count }}&lt;/div&gt;  // actions  methods: {    increment () {      this.count++    }  }})</code></pre><p>这个状态自管理应用包含以下几个部分：</p><ul><li>state：驱动应用的数据源；</li><li>view：以声明方式将state映射到视图；</li><li>actions：响应在 view上的用户输入导致的状态变化。</li></ul><p>这是一个普通的组件从样式渲染到数据绑定再到数据变化，单一的状态比较清晰，遇到多个组件共享状态时，这种简洁性很容易被破坏且难以管理。因此，把组件的共享状态抽出来，以一个全局单例模式管理，这就是VUEX背后的基本思想。</p><p><img src="../assets/vuex.png" alt=""></p><p>后续用完之后再来写: )</p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seccloud </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步调用</title>
      <link href="/2018/01/08/async&amp;promise/"/>
      <url>/2018/01/08/async&amp;promise/</url>
      
        <content type="html"><![CDATA[<h2 id="异步组合使用"><a href="#异步组合使用" class="headerlink" title="异步组合使用"></a>异步组合使用</h2><pre><code class="javascript">function sleep(duration){    return new Promise(function(resolve){        setTimeout(resolve, duration);    })}async function changeColor(duration,color){    document.getElementById(&quot;traffic-light&quot;).style.background = color;    await sleep(duration);}async function main(){    while(true){        await changeColor(3000,&quot;green&quot;);        await changeColor(1000, &quot;yellow&quot;);        await changeColor(2000, &quot;red&quot;);    }}main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容易忘的用法</title>
      <link href="/2018/01/08/basic/"/>
      <url>/2018/01/08/basic/</url>
      
        <content type="html"><![CDATA[<h2 id="1-代码托管"><a href="#1-代码托管" class="headerlink" title="1.代码托管"></a>1.代码托管</h2><p>基于gitLab的代码版本管理，简单的写下流程吧</p><ol><li>git clone 项目远程主机路径/git clone -b 具体分支 项目远程主机；会有一个默认的remote叫做origin</li><li>git remote add xxx（自己的远程主机名） 远程主机路径</li><li>git push xxx 本地分支名称:远程分支名称（没有分支名称时自动创建）</li><li>git fetch origin / git merge origin 分支名</li></ol><p>后续用到了再来写吧: )</p>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
